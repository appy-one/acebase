(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.acebase=f()}})((function(){var define,module,exports;return function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,(function(r){var n=e[i][1][r];return o(n||r)}),p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r}()({1:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.BrowserAceBase=void 0;const acebase_local_1=require("./acebase-local");const indexed_db_1=require("./storage/custom/indexed-db");const deprecatedConstructorError=`Using AceBase constructor in the browser to use localStorage is deprecated!\nSwitch to:\nIndexedDB implementation (FASTER, MORE RELIABLE):\n    let db = AceBase.WithIndexedDB(name, settings)\nOr, new LocalStorage implementation:\n    let db = AceBase.WithLocalStorage(name, settings)\nOr, write your own CustomStorage adapter:\n    let myCustomStorage = new CustomStorageSettings({ ... });\n    let db = new AceBase(name, { storage: myCustomStorage })`;class BrowserAceBase extends acebase_local_1.AceBase{constructor(name,settings){if(typeof settings!=="object"||typeof settings.storage!=="object"){throw new Error(deprecatedConstructorError)}super(name,settings);this.settings.ipcEvents=settings.multipleTabs===true}static WithIndexedDB(dbname,init={}){return(0,indexed_db_1.createIndexedDBInstance)(dbname,init)}}exports.BrowserAceBase=BrowserAceBase},{"./acebase-local":2,"./storage/custom/indexed-db":22}],2:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.AceBase=exports.AceBaseLocalSettings=exports.IndexedDBStorageSettings=exports.LocalStorageSettings=void 0;const acebase_core_1=require("acebase-core");const binary_1=require("./storage/binary");const api_local_1=require("./api-local");const local_storage_1=require("./storage/custom/local-storage");Object.defineProperty(exports,"LocalStorageSettings",{enumerable:true,get:function(){return local_storage_1.LocalStorageSettings}});const settings_1=require("./storage/custom/indexed-db/settings");Object.defineProperty(exports,"IndexedDBStorageSettings",{enumerable:true,get:function(){return settings_1.IndexedDBStorageSettings}});class AceBaseLocalSettings extends acebase_core_1.AceBaseBaseSettings{constructor(options={}){super(options);if(options.storage){this.storage=options.storage;if(options.ipc){this.storage.ipc=options.ipc}if(options.transactions){this.storage.transactions=options.transactions}}}}exports.AceBaseLocalSettings=AceBaseLocalSettings;class AceBase extends acebase_core_1.AceBaseBase{constructor(dbname,init={}){const settings=new AceBaseLocalSettings(init);super(dbname,settings);this.recovery={repairNode:async(path,options)=>{await this.ready();if(this.api.storage instanceof binary_1.AceBaseStorage){await this.api.storage.repairNode(path,options)}else if(!this.api.storage.repairNode){throw new Error(`repairNode is not supported with chosen storage engine`)}},repairNodeTree:async path=>{await this.ready();const storage=this.api.storage;await storage.repairNodeTree(path)}};const apiSettings={db:this,settings:settings};this.api=new api_local_1.LocalApi(dbname,apiSettings,(()=>{this.emit("ready")}))}async close(){await this.api.storage.close()}get settings(){const ipc=this.api.storage.ipc,debug=this.debug;return{get logLevel(){return debug.level},set logLevel(level){debug.setLevel(level)},get ipcEvents(){return ipc.eventsEnabled},set ipcEvents(enabled){ipc.eventsEnabled=enabled}}}static WithLocalStorage(dbname,settings={}){const db=(0,local_storage_1.createLocalStorageInstance)(dbname,settings);return db}static WithIndexedDB(dbname,init={}){throw new Error(`IndexedDB storage can only be used in browser contexts`)}}exports.AceBase=AceBase},{"./api-local":3,"./storage/binary":18,"./storage/custom/indexed-db/settings":23,"./storage/custom/local-storage":25,"acebase-core":43}],3:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.LocalApi=void 0;const acebase_core_1=require("acebase-core");const binary_1=require("./storage/binary");const sqlite_1=require("./storage/sqlite");const mssql_1=require("./storage/mssql");const custom_1=require("./storage/custom");const node_value_types_1=require("./node-value-types");const query_1=require("./query");const node_errors_1=require("./node-errors");class LocalApi extends acebase_core_1.Api{constructor(dbname="default",init,readyCallback){super();this.db=init.db;const storageEnv={logLevel:init.settings.logLevel};if(typeof init.settings.storage==="object"){if(sqlite_1.SQLiteStorageSettings&&init.settings.storage instanceof sqlite_1.SQLiteStorageSettings){this.storage=new sqlite_1.SQLiteStorage(dbname,init.settings.storage,storageEnv)}else if(mssql_1.MSSQLStorageSettings&&init.settings.storage instanceof mssql_1.MSSQLStorageSettings){this.storage=new mssql_1.MSSQLStorage(dbname,init.settings.storage,storageEnv)}else if(custom_1.CustomStorageSettings&&init.settings.storage instanceof custom_1.CustomStorageSettings){this.storage=new custom_1.CustomStorage(dbname,init.settings.storage,storageEnv)}else{const storageSettings=init.settings.storage instanceof binary_1.AceBaseStorageSettings?init.settings.storage:new binary_1.AceBaseStorageSettings(init.settings.storage);this.storage=new binary_1.AceBaseStorage(dbname,storageSettings,storageEnv)}}else{this.storage=new binary_1.AceBaseStorage(dbname,new binary_1.AceBaseStorageSettings,storageEnv)}this.storage.on("ready",readyCallback)}async stats(options){return this.storage.stats}subscribe(path,event,callback){this.storage.subscriptions.add(path,event,callback)}unsubscribe(path,event,callback){this.storage.subscriptions.remove(path,event,callback)}async set(path,value,options={suppress_events:false,context:null}){const cursor=await this.storage.setNode(path,value,{suppress_events:options.suppress_events,context:options.context});return Object.assign({},cursor&&{cursor:cursor})}async update(path,updates,options={suppress_events:false,context:null}){const cursor=await this.storage.updateNode(path,updates,{suppress_events:options.suppress_events,context:options.context});return Object.assign({},cursor&&{cursor:cursor})}get transactionLoggingEnabled(){return this.storage.settings.transactions&&this.storage.settings.transactions.log===true}async get(path,options){if(!options){options={}}if(typeof options.include!=="undefined"&&!(options.include instanceof Array)){throw new TypeError(`options.include must be an array of key names`)}if(typeof options.exclude!=="undefined"&&!(options.exclude instanceof Array)){throw new TypeError(`options.exclude must be an array of key names`)}if(["undefined","boolean"].indexOf(typeof options.child_objects)<0){throw new TypeError(`options.child_objects must be a boolean`)}const node=await this.storage.getNode(path,options);return{value:node.value,context:{acebase_cursor:node.cursor},cursor:node.cursor}}async transaction(path,callback,options={suppress_events:false,context:null}){const cursor=await this.storage.transactNode(path,callback,{suppress_events:options.suppress_events,context:options.context});return Object.assign({},cursor&&{cursor:cursor})}async exists(path){const nodeInfo=await this.storage.getNodeInfo(path);return nodeInfo.exists}async query(path,query,options={snapshots:false}){const results=await(0,query_1.executeQuery)(this,path,query,options);return results}createIndex(path,key,options){return this.storage.indexes.create(path,key,options)}async getIndexes(){return this.storage.indexes.list()}async deleteIndex(filePath){return this.storage.indexes.delete(filePath)}async reflect(path,type,args){args=args||{};const getChildren=async(path,limit=50,skip=0,from=null)=>{if(typeof limit==="string"){limit=parseInt(limit)}if(typeof skip==="string"){skip=parseInt(skip)}if(["null","undefined"].includes(from)){from=null}const children=[];let n=0,stop=false,more=false;await this.storage.getChildren(path).next((childInfo=>{if(stop){more=true;return false}n++;const include=from!==null?childInfo.key>from:skip===0||n>skip;if(include){children.push(Object.assign({key:typeof childInfo.key==="string"?childInfo.key:childInfo.index,type:childInfo.valueTypeName,value:childInfo.value},typeof childInfo.address==="object"&&"pageNr"in childInfo.address&&{address:{pageNr:childInfo.address.pageNr,recordNr:childInfo.address.recordNr}}))}stop=limit>0&&children.length===limit})).catch((err=>{if(!(err instanceof node_errors_1.NodeNotFoundError)){throw err}}));return{more:more,list:children}};switch(type){case"children":{const result=await getChildren(path,args.limit,args.skip,args.from);return result}case"info":{const info={key:"",exists:false,type:"unknown",value:undefined,address:undefined,children:{count:0,more:false,list:[]}};const nodeInfo=await this.storage.getNodeInfo(path,{include_child_count:args.child_count===true});info.key=typeof nodeInfo.key!=="undefined"?nodeInfo.key:nodeInfo.index;info.exists=nodeInfo.exists;info.type=nodeInfo.exists?nodeInfo.valueTypeName:undefined;info.value=nodeInfo.value;info.address=typeof nodeInfo.address==="object"&&"pageNr"in nodeInfo.address?{pageNr:nodeInfo.address.pageNr,recordNr:nodeInfo.address.recordNr}:undefined;const isObjectOrArray=nodeInfo.exists&&nodeInfo.address&&[node_value_types_1.VALUE_TYPES.OBJECT,node_value_types_1.VALUE_TYPES.ARRAY].includes(nodeInfo.type);if(args.child_count===true){info.children={count:isObjectOrArray?nodeInfo.childCount:0}}else if(typeof args.child_limit==="number"&&args.child_limit>0){if(isObjectOrArray){info.children=await getChildren(path,args.child_limit,args.child_skip,args.child_from)}}return info}}}export(path,stream,options={format:"json",type_safe:true}){return this.storage.exportNode(path,stream,options)}import(path,read,options={format:"json",suppress_events:false,method:"set"}){return this.storage.importNode(path,read,options)}async setSchema(path,schema,warnOnly=false){return this.storage.setSchema(path,schema,warnOnly)}async getSchema(path){return this.storage.getSchema(path)}async getSchemas(){return this.storage.getSchemas()}async validateSchema(path,value,isUpdate){return this.storage.validateSchema(path,value,{updates:isUpdate})}async getMutations(filter){if(typeof this.storage.getMutations!=="function"){throw new Error("Used storage type does not support getMutations")}if(typeof filter!=="object"){throw new Error("No filter specified")}if(typeof filter.cursor!=="string"&&typeof filter.timestamp!=="number"){throw new Error("No cursor or timestamp given")}return this.storage.getMutations(filter)}async getChanges(filter){if(typeof this.storage.getChanges!=="function"){throw new Error("Used storage type does not support getChanges")}if(typeof filter!=="object"){throw new Error("No filter specified")}if(typeof filter.cursor!=="string"&&typeof filter.timestamp!=="number"){throw new Error("No cursor or timestamp given")}return this.storage.getChanges(filter)}}exports.LocalApi=LocalApi},{"./node-errors":11,"./node-value-types":14,"./query":17,"./storage/binary":18,"./storage/custom":21,"./storage/mssql":30,"./storage/sqlite":31,"acebase-core":43}],4:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.assert=void 0;function assert(condition,error){if(!condition){throw new Error(`Assertion failed: ${error!==null&&error!==void 0?error:"check your code"}`)}}exports.assert=assert},{}],5:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.AsyncTaskBatch=void 0;class AsyncTaskBatch{constructor(limit=1e3,options){this.limit=limit;this.options=options;this.added=0;this.scheduled=[];this.running=0;this.results=[];this.done=false}async execute(task,index){var _a,_b;try{this.running++;const result=await task();this.results[index]=result;this.running--;if(this.running===0&&this.scheduled.length===0){this.done=true;(_a=this.doneCallback)===null||_a===void 0?void 0:_a.call(this,this.results)}else if(this.scheduled.length>0){const next=this.scheduled.shift();this.execute(next.task,next.index)}}catch(err){this.done=true;(_b=this.errorCallback)===null||_b===void 0?void 0:_b.call(this,err)}}add(task){var _a;if(this.done){throw new Error(`Cannot add to a batch that has already finished. Use wait option and start batch processing manually if you are adding tasks in an async loop`)}const index=this.added++;if(((_a=this.options)===null||_a===void 0?void 0:_a.wait)!==true&&this.running<this.limit){this.execute(task,index)}else{this.scheduled.push({task:task,index:index})}}start(){while(this.running<this.limit){const next=this.scheduled.shift();this.execute(next.task,next.index)}}async finish(){if(this.running===0&&this.scheduled.length===0){return this.results}await new Promise(((resolve,reject)=>{this.doneCallback=resolve;this.errorCallback=reject}));return this.results}}exports.AsyncTaskBatch=AsyncTaskBatch},{}],6:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.SchemaValidationError=exports.StorageSettings=exports.ICustomStorageNodeMetaData=exports.ICustomStorageNode=exports.CustomStorageHelpers=exports.CustomStorageSettings=exports.CustomStorageTransaction=exports.MSSQLStorageSettings=exports.SQLiteStorageSettings=exports.AceBaseStorageSettings=exports.IndexedDBStorageSettings=exports.LocalStorageSettings=exports.AceBaseLocalSettings=exports.AceBase=exports.PartialArray=exports.proxyAccess=exports.ID=exports.ObjectCollection=exports.TypeMappings=exports.PathReference=exports.EventSubscription=exports.EventStream=exports.DataReferencesArray=exports.DataSnapshotsArray=exports.DataReference=exports.DataSnapshot=void 0;const acebase_core_1=require("acebase-core");Object.defineProperty(exports,"DataReference",{enumerable:true,get:function(){return acebase_core_1.DataReference}});Object.defineProperty(exports,"DataSnapshot",{enumerable:true,get:function(){return acebase_core_1.DataSnapshot}});Object.defineProperty(exports,"EventSubscription",{enumerable:true,get:function(){return acebase_core_1.EventSubscription}});Object.defineProperty(exports,"PathReference",{enumerable:true,get:function(){return acebase_core_1.PathReference}});Object.defineProperty(exports,"TypeMappings",{enumerable:true,get:function(){return acebase_core_1.TypeMappings}});Object.defineProperty(exports,"ID",{enumerable:true,get:function(){return acebase_core_1.ID}});Object.defineProperty(exports,"proxyAccess",{enumerable:true,get:function(){return acebase_core_1.proxyAccess}});Object.defineProperty(exports,"DataSnapshotsArray",{enumerable:true,get:function(){return acebase_core_1.DataSnapshotsArray}});Object.defineProperty(exports,"ObjectCollection",{enumerable:true,get:function(){return acebase_core_1.ObjectCollection}});Object.defineProperty(exports,"DataReferencesArray",{enumerable:true,get:function(){return acebase_core_1.DataReferencesArray}});Object.defineProperty(exports,"EventStream",{enumerable:true,get:function(){return acebase_core_1.EventStream}});Object.defineProperty(exports,"PartialArray",{enumerable:true,get:function(){return acebase_core_1.PartialArray}});const acebase_local_1=require("./acebase-local");const acebase_browser_1=require("./acebase-browser");Object.defineProperty(exports,"AceBase",{enumerable:true,get:function(){return acebase_browser_1.BrowserAceBase}});const custom_1=require("./storage/custom");const acebase={AceBase:acebase_browser_1.BrowserAceBase,AceBaseLocalSettings:acebase_local_1.AceBaseLocalSettings,DataReference:acebase_core_1.DataReference,DataSnapshot:acebase_core_1.DataSnapshot,EventSubscription:acebase_core_1.EventSubscription,PathReference:acebase_core_1.PathReference,TypeMappings:acebase_core_1.TypeMappings,CustomStorageSettings:custom_1.CustomStorageSettings,CustomStorageTransaction:custom_1.CustomStorageTransaction,CustomStorageHelpers:custom_1.CustomStorageHelpers,ID:acebase_core_1.ID,proxyAccess:acebase_core_1.proxyAccess,DataSnapshotsArray:acebase_core_1.DataSnapshotsArray};if(typeof window!=="undefined"){window.acebase=acebase;window.AceBase=acebase_browser_1.BrowserAceBase}exports.default=acebase;var acebase_local_2=require("./acebase-local");Object.defineProperty(exports,"AceBaseLocalSettings",{enumerable:true,get:function(){return acebase_local_2.AceBaseLocalSettings}});Object.defineProperty(exports,"LocalStorageSettings",{enumerable:true,get:function(){return acebase_local_2.LocalStorageSettings}});Object.defineProperty(exports,"IndexedDBStorageSettings",{enumerable:true,get:function(){return acebase_local_2.IndexedDBStorageSettings}});var binary_1=require("./storage/binary");Object.defineProperty(exports,"AceBaseStorageSettings",{enumerable:true,get:function(){return binary_1.AceBaseStorageSettings}});var sqlite_1=require("./storage/sqlite");Object.defineProperty(exports,"SQLiteStorageSettings",{enumerable:true,get:function(){return sqlite_1.SQLiteStorageSettings}});var mssql_1=require("./storage/mssql");Object.defineProperty(exports,"MSSQLStorageSettings",{enumerable:true,get:function(){return mssql_1.MSSQLStorageSettings}});var custom_2=require("./storage/custom");Object.defineProperty(exports,"CustomStorageTransaction",{enumerable:true,get:function(){return custom_2.CustomStorageTransaction}});Object.defineProperty(exports,"CustomStorageSettings",{enumerable:true,get:function(){return custom_2.CustomStorageSettings}});Object.defineProperty(exports,"CustomStorageHelpers",{enumerable:true,get:function(){return custom_2.CustomStorageHelpers}});Object.defineProperty(exports,"ICustomStorageNode",{enumerable:true,get:function(){return custom_2.ICustomStorageNode}});Object.defineProperty(exports,"ICustomStorageNodeMetaData",{enumerable:true,get:function(){return custom_2.ICustomStorageNodeMetaData}});var storage_1=require("./storage");Object.defineProperty(exports,"StorageSettings",{enumerable:true,get:function(){return storage_1.StorageSettings}});Object.defineProperty(exports,"SchemaValidationError",{enumerable:true,get:function(){return storage_1.SchemaValidationError}})},{"./acebase-browser":1,"./acebase-local":2,"./storage":28,"./storage/binary":18,"./storage/custom":21,"./storage/mssql":30,"./storage/sqlite":31,"acebase-core":43}],7:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.ArrayIndex=exports.GeoIndex=exports.FullTextIndex=exports.DataIndex=void 0;const not_supported_1=require("../not-supported");class DataIndex extends not_supported_1.NotSupported{}exports.DataIndex=DataIndex;class FullTextIndex extends not_supported_1.NotSupported{}exports.FullTextIndex=FullTextIndex;class GeoIndex extends not_supported_1.NotSupported{}exports.GeoIndex=GeoIndex;class ArrayIndex extends not_supported_1.NotSupported{}exports.ArrayIndex=ArrayIndex},{"../not-supported":15}],8:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.NetIPCServer=exports.IPCSocketPeer=exports.RemoteIPCPeer=exports.IPCPeer=void 0;const acebase_core_1=require("acebase-core");const ipc_1=require("./ipc");const not_supported_1=require("../not-supported");Object.defineProperty(exports,"RemoteIPCPeer",{enumerable:true,get:function(){return not_supported_1.NotSupported}});Object.defineProperty(exports,"IPCSocketPeer",{enumerable:true,get:function(){return not_supported_1.NotSupported}});Object.defineProperty(exports,"NetIPCServer",{enumerable:true,get:function(){return not_supported_1.NotSupported}});class IPCPeer extends ipc_1.AceBaseIPCPeer{constructor(storage){super(storage,acebase_core_1.ID.generate());this.masterPeerId=this.id;this.ipcType="browser.bcc";addEventListener("beforeunload",(()=>{this.exit()}));if(typeof BroadcastChannel!=="undefined"){this.channel=new BroadcastChannel(`acebase:${storage.name}`)}else if(typeof localStorage!=="undefined"){const listeners=[null];const notImplemented=()=>{throw new Error("Not implemented")};this.channel={name:`acebase:${storage.name}`,postMessage:message=>{const messageId=acebase_core_1.ID.generate(),key=`acebase:${storage.name}:${this.id}:${messageId}`,payload=JSON.stringify(acebase_core_1.Transport.serialize(message));localStorage.setItem(key,payload);setTimeout((()=>localStorage.removeItem(key)),10)},set onmessage(handler){listeners[0]=handler},set onmessageerror(handler){notImplemented()},close(){notImplemented()},addEventListener(event,callback){if(event!=="message"){notImplemented()}listeners.push(callback)},removeEventListener(event,callback){const i=listeners.indexOf(callback);i>=1&&listeners.splice(i,1)},dispatchEvent(event){listeners.forEach((callback=>{try{callback&&callback(event)}catch(err){console.error(err)}}));return true}};addEventListener("storage",(event=>{const[acebase,dbname,peerId,messageId]=event.key.split(":");if(acebase!=="acebase"||dbname!==storage.name||peerId===this.id||event.newValue===null){return}const message=acebase_core_1.Transport.deserialize(JSON.parse(event.newValue));this.channel.dispatchEvent({data:message})}))}else{this.storage.debug.warn(`[BroadcastChannel] not supported`);this.sendMessage=()=>{};return}this.channel.addEventListener("message",(async event=>{const message=event.data;if(message.to&&message.to!==this.id){return}storage.debug.verbose(`[BroadcastChannel] received: `,message);if(message.type==="hello"&&message.from<this.masterPeerId){this.masterPeerId=message.from;storage.debug.log(`[BroadcastChannel] Tab ${this.masterPeerId} is the master.`)}else if(message.type==="bye"&&message.from===this.masterPeerId){storage.debug.log(`[BroadcastChannel] Master tab ${this.masterPeerId} is leaving`);const allPeerIds=this.peers.map((peer=>peer.id)).concat(this.id).filter((id=>id!==this.masterPeerId));this.masterPeerId=allPeerIds.sort()[0];storage.debug.log(`[BroadcastChannel] ${this.masterPeerId===this.id?"We are":`tab ${this.masterPeerId} is`} the new master. Requesting ${this._locks.length} locks (${this._locks.filter((r=>!r.granted)).length} pending)`);const requests=this._locks.splice(0);await Promise.all(requests.filter((req=>req.granted)).map((async req=>{let released,movedToParent;req.lock.release=()=>new Promise((resolve=>released=resolve));req.lock.moveToParent=()=>new Promise((resolve=>movedToParent=resolve));const lock=await this.lock({path:req.lock.path,write:req.lock.forWriting,tid:req.lock.tid,comment:req.lock.comment});if(movedToParent){const newLock=await lock.moveToParent();movedToParent(newLock)}if(released){await lock.release();released()}})));await Promise.all(requests.filter((req=>!req.granted)).map((async req=>{await this.lock(req.request)})))}return this.handleMessage(message)}));const helloMsg={type:"hello",from:this.id,data:undefined};this.sendMessage(helloMsg)}sendMessage(message){this.storage.debug.verbose(`[BroadcastChannel] sending: `,message);this.channel.postMessage(message)}}exports.IPCPeer=IPCPeer},{"../not-supported":15,"./ipc":9,"acebase-core":43}],9:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.AceBaseIPCPeer=exports.AceBaseIPCPeerExitingError=void 0;const acebase_core_1=require("acebase-core");const node_lock_1=require("../node-lock");class AceBaseIPCPeerExitingError extends Error{constructor(message){super(`Exiting: ${message}`)}}exports.AceBaseIPCPeerExitingError=AceBaseIPCPeerExitingError;class AceBaseIPCPeer extends acebase_core_1.SimpleEventEmitter{get isMaster(){return this.masterPeerId===this.id}constructor(storage,id,dbname=storage.name){super();this.storage=storage;this.id=id;this.dbname=dbname;this.ipcType="ipc";this.ourSubscriptions=[];this.remoteSubscriptions=[];this.peers=[];this._exiting=false;this._locks=[];this._requests=new Map;this._eventsEnabled=true;this._nodeLocker=new node_lock_1.NodeLocker(storage.debug,storage.settings.lockTimeout);storage.on("subscribe",(subscription=>{storage.debug.verbose(`database subscription being added on peer ${this.id}`);const remoteSubscription=this.remoteSubscriptions.find((sub=>sub.callback===subscription.callback));if(remoteSubscription){return}const othersAlreadyNotifying=this.ourSubscriptions.some((sub=>sub.event===subscription.event&&sub.path===subscription.path));this.ourSubscriptions.push(subscription);if(othersAlreadyNotifying){return}const message={type:"subscribe",from:this.id,data:{path:subscription.path,event:subscription.event}};this.sendMessage(message)}));storage.on("unsubscribe",(subscription=>{const remoteSubscription=this.remoteSubscriptions.find((sub=>sub.callback===subscription.callback));if(remoteSubscription){this.remoteSubscriptions.splice(this.remoteSubscriptions.indexOf(remoteSubscription),1);return}this.ourSubscriptions.filter((sub=>sub.path===subscription.path&&(!subscription.event||sub.event===subscription.event)&&(!subscription.callback||sub.callback===subscription.callback))).forEach((sub=>{this.ourSubscriptions.splice(this.ourSubscriptions.indexOf(sub),1);const message={type:"unsubscribe",from:this.id,data:{path:sub.path,event:sub.event}};this.sendMessage(message)}))}))}async exit(code=0){if(this._exiting){return this.once("exit")}this._exiting=true;this.storage.debug.warn(`Received ${this.isMaster?"master":"worker "+this.id} process exit request`);if(this._locks.length>0){this.storage.debug.warn(`Waiting for ${this.isMaster?"master":"worker"} ${this.id} locks to clear`);await this.once("locks-cleared")}this.sayGoodbye(this.id);this.storage.debug.warn(`${this.isMaster?"Master":"Worker "+this.id} will now exit`);this.emitOnce("exit",code)}sayGoodbye(forPeerId){const bye={type:"bye",from:forPeerId,data:undefined};this.sendMessage(bye)}addPeer(id,sendReply=true){if(this._exiting){return}const peer=this.peers.find((w=>w.id===id));if(!peer){this.peers.push({id:id,lastSeen:Date.now()})}if(sendReply){const helloMessage={type:"hello",from:this.id,to:id,data:undefined};this.sendMessage(helloMessage);this.ourSubscriptions.forEach((sub=>{const message={type:"subscribe",from:this.id,to:id,data:{path:sub.path,event:sub.event}};this.sendMessage(message)}))}}removePeer(id,ignoreUnknown=false){if(this._exiting){return}const peer=this.peers.find((peer=>peer.id===id));if(!peer){if(!ignoreUnknown){throw new Error(`We are supposed to know this peer!`)}return}this.peers.splice(this.peers.indexOf(peer),1);const subscriptions=this.remoteSubscriptions.filter((sub=>sub.for===id));subscriptions.forEach((sub=>{this.remoteSubscriptions.splice(this.remoteSubscriptions.indexOf(sub),1);this.storage.subscriptions.remove(sub.path,sub.event,sub.callback)}))}addRemoteSubscription(peerId,details){if(this._exiting){return}if(this.remoteSubscriptions.some((sub=>sub.for===peerId&&sub.event===details.event&&sub.path===details.path))){return}const subscribeCallback=(err,path,val,previous,context)=>{const eventMessage={type:"event",from:this.id,to:peerId,path:details.path,event:details.event,data:{path:path,val:val,previous:previous,context:context}};this.sendMessage(eventMessage)};this.remoteSubscriptions.push({for:peerId,event:details.event,path:details.path,callback:subscribeCallback});this.storage.subscriptions.add(details.path,details.event,subscribeCallback)}cancelRemoteSubscription(peerId,details){const sub=this.remoteSubscriptions.find((sub=>sub.for===peerId&&sub.event===details.event&&sub.path===details.event));if(!sub){return}this.storage.subscriptions.remove(details.path,details.event,sub.callback)}async handleMessage(message){switch(message.type){case"hello":return this.addPeer(message.from,message.to!==this.id);case"bye":return this.removePeer(message.from,true);case"subscribe":return this.addRemoteSubscription(message.from,message.data);case"unsubscribe":return this.cancelRemoteSubscription(message.from,message.data);case"event":{if(!this._eventsEnabled){break}const eventMessage=message;const context=eventMessage.data.context||{};context.acebase_ipc={type:this.ipcType,origin:eventMessage.from};const subscriptions=this.ourSubscriptions.filter((sub=>sub.event===eventMessage.event&&sub.path===eventMessage.path));subscriptions.forEach((sub=>{sub.callback(null,eventMessage.data.path,eventMessage.data.val,eventMessage.data.previous,context)}));break}case"lock-request":{if(!this.isMaster){throw new Error(`Workers are not supposed to receive lock requests!`)}const request=message;const result={type:"lock-result",id:request.id,from:this.id,to:request.from,ok:true,data:undefined};try{const lock=await this.lock(request.data);result.data={id:lock.id,path:lock.path,tid:lock.tid,write:lock.forWriting,expires:lock.expires,comment:lock.comment}}catch(err){result.ok=false;result.reason=err.stack||err.message||err}return this.sendMessage(result)}case"lock-result":{if(this.isMaster){throw new Error(`Masters are not supposed to receive results for lock requests!`)}const result=message;const request=this._requests.get(result.id);if(typeof request!=="object"){throw new Error(`The request must be known to us!`)}if(result.ok){request.resolve(result.data)}else{request.reject(new Error(result.reason))}return}case"unlock-request":{if(!this.isMaster){throw new Error(`Workers are not supposed to receive unlock requests!`)}const request=message;const result={type:"unlock-result",id:request.id,from:this.id,to:request.from,ok:true,data:{id:request.data.id}};try{const lockInfo=this._locks.find((l=>{var _a;return((_a=l.lock)===null||_a===void 0?void 0:_a.id)===request.data.id}));await lockInfo.lock.release()}catch(err){result.ok=false;result.reason=err.stack||err.message||err}return this.sendMessage(result)}case"unlock-result":{if(this.isMaster){throw new Error(`Masters are not supposed to receive results for unlock requests!`)}const result=message;const request=this._requests.get(result.id);if(typeof request!=="object"){throw new Error(`The request must be known to us!`)}if(result.ok){request.resolve(result.data)}else{request.reject(new Error(result.reason))}return}case"move-lock-request":{if(!this.isMaster){throw new Error(`Workers are not supposed to receive move lock requests!`)}const request=message;const result={type:"lock-result",id:request.id,from:this.id,to:request.from,ok:true,data:undefined};try{let movedLock;const lockRequest=this._locks.find((r=>{var _a;return((_a=r.lock)===null||_a===void 0?void 0:_a.id)===request.data.id}));if(request.data.move_to==="parent"){movedLock=await lockRequest.lock.moveToParent()}else{throw new Error(`Unknown lock move_to "${request.data.move_to}"`)}lockRequest.lock=movedLock;result.data={id:movedLock.id,path:movedLock.path,tid:movedLock.tid,write:movedLock.forWriting,expires:movedLock.expires,comment:movedLock.comment}}catch(err){result.ok=false;result.reason=err.stack||err.message||err}return this.sendMessage(result)}case"notification":{return this.emit("notification",message)}case"request":{return this.emit("request",message)}case"result":{const result=message;const request=this._requests.get(result.id);if(typeof request!=="object"){throw new Error(`Result of unknown request received`)}if(result.ok){request.resolve(result.data)}else{request.reject(new Error(result.reason))}}}}async lock(details){if(this._exiting){const tidApproved=this._locks.find((l=>l.tid===details.tid&&l.granted));if(!tidApproved){throw new AceBaseIPCPeerExitingError("new transaction lock denied because the IPC peer is exiting")}}const removeLock=lockDetails=>{this._locks.splice(this._locks.indexOf(lockDetails),1);if(this._locks.length===0){this.emit("locks-cleared")}};if(this.isMaster){const lockInfo={tid:details.tid,granted:false,request:details,lock:null};this._locks.push(lockInfo);const lock=await this._nodeLocker.lock(details.path,details.tid,details.write,details.comment);lockInfo.tid=lock.tid;lockInfo.granted=true;const createIPCLock=lock=>({get id(){return lock.id},get tid(){return lock.tid},get path(){return lock.path},get forWriting(){return lock.forWriting},get expires(){return lock.expires},get comment(){return lock.comment},get state(){return lock.state},release:async()=>{await lock.release();removeLock(lockInfo)},moveToParent:async()=>{const parentLock=await lock.moveToParent();lockInfo.lock=createIPCLock(parentLock);return lockInfo.lock}});lockInfo.lock=createIPCLock(lock);return lockInfo.lock}else{const lockInfo={tid:details.tid,granted:false,request:details,lock:null};this._locks.push(lockInfo);const createIPCLock=result=>{lockInfo.granted=true;lockInfo.tid=result.tid;lockInfo.lock={id:result.id,tid:result.tid,path:result.path,forWriting:result.write,state:node_lock_1.LOCK_STATE.LOCKED,expires:result.expires,comment:result.comment,release:async()=>{const req={type:"unlock-request",id:acebase_core_1.ID.generate(),from:this.id,to:this.masterPeerId,data:{id:lockInfo.lock.id}};await this.request(req);lockInfo.lock.state=node_lock_1.LOCK_STATE.DONE;this.storage.debug.verbose(`Worker ${this.id} released lock ${lockInfo.lock.id} (tid ${lockInfo.lock.tid}, ${lockInfo.lock.comment}, "/${lockInfo.lock.path}", ${lockInfo.lock.forWriting?"write":"read"})`);removeLock(lockInfo)},moveToParent:async()=>{const req={type:"move-lock-request",id:acebase_core_1.ID.generate(),from:this.id,to:this.masterPeerId,data:{id:lockInfo.lock.id,move_to:"parent"}};let result;try{result=await this.request(req)}catch(err){lockInfo.lock.state=node_lock_1.LOCK_STATE.DONE;removeLock(lockInfo);throw err}lockInfo.lock=createIPCLock(result);return lockInfo.lock}};return lockInfo.lock};const req={type:"lock-request",id:acebase_core_1.ID.generate(),from:this.id,to:this.masterPeerId,data:details};let result,err;try{result=await this.request(req)}catch(e){err=e;result=null}if(err){removeLock(lockInfo);throw err}return createIPCLock(result)}}async request(req){let resolve,reject;const promise=new Promise(((rs,rj)=>{resolve=result=>{this._requests.delete(req.id);rs(result)};reject=err=>{this._requests.delete(req.id);rj(err)}}));this._requests.set(req.id,{resolve:resolve,reject:reject,request:req});this.sendMessage(req);return promise}sendRequest(request){const req={type:"request",from:this.id,to:this.masterPeerId,id:acebase_core_1.ID.generate(),data:request};return this.request(req).catch((err=>{this.storage.debug.error(err);throw err}))}replyRequest(requestMessage,result){const reply={type:"result",id:requestMessage.id,ok:true,from:this.id,to:requestMessage.from,data:result};this.sendMessage(reply)}sendNotification(notification){const msg={type:"notification",from:this.id,data:notification};this.sendMessage(msg)}get eventsEnabled(){return this._eventsEnabled}set eventsEnabled(enabled){this.storage.debug.log(`ipc events ${enabled?"enabled":"disabled"}`);this._eventsEnabled=enabled}}exports.AceBaseIPCPeer=AceBaseIPCPeer},{"../node-lock":13,"acebase-core":43}],10:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.RemovedNodeAddress=exports.NodeAddress=void 0;class NodeAddress{constructor(path){this.path=path}toString(){return`"/${this.path}"`}equals(address){return this.path===address.path}}exports.NodeAddress=NodeAddress;class RemovedNodeAddress extends NodeAddress{constructor(path){super(path)}toString(){return`"/${this.path}" (removed)`}equals(address){return address instanceof RemovedNodeAddress&&this.path===address.path}}exports.RemovedNodeAddress=RemovedNodeAddress},{}],11:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.NodeRevisionError=exports.NodeNotFoundError=void 0;class NodeNotFoundError extends Error{}exports.NodeNotFoundError=NodeNotFoundError;class NodeRevisionError extends Error{}exports.NodeRevisionError=NodeRevisionError},{}],12:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.NodeInfo=void 0;const node_value_types_1=require("./node-value-types");const acebase_core_1=require("acebase-core");class NodeInfo{constructor(info){this.path=info.path;this.type=info.type;this.index=info.index;this.key=info.key;this.exists=info.exists;this.address=info.address;this.value=info.value;this.childCount=info.childCount;if(typeof this.path==="string"&&(typeof this.key==="undefined"&&typeof this.index==="undefined")){const pathInfo=acebase_core_1.PathInfo.get(this.path);if(typeof pathInfo.key==="number"){this.index=pathInfo.key}else{this.key=pathInfo.key}}if(typeof this.exists==="undefined"){this.exists=true}}get valueType(){return this.type}get valueTypeName(){return(0,node_value_types_1.getValueTypeName)(this.valueType)}toString(){if(!this.exists){return`"${this.path}" doesn't exist`}if(this.address){return`"${this.path}" is ${this.valueTypeName} stored at ${this.address.toString()}`}else{return`"${this.path}" is ${this.valueTypeName} with value ${this.value}`}}}exports.NodeInfo=NodeInfo},{"./node-value-types":14,"acebase-core":43}],13:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.NodeLock=exports.NodeLocker=exports.LOCK_STATE=void 0;const acebase_core_1=require("acebase-core");const assert_1=require("./assert");const DEBUG_MODE=false;const DEFAULT_LOCK_TIMEOUT=120;exports.LOCK_STATE={PENDING:"pending",LOCKED:"locked",EXPIRED:"expired",DONE:"done"};class NodeLocker{constructor(debug,lockTimeout=DEFAULT_LOCK_TIMEOUT){this._locks=[];this._lastTid=0;this.debug=debug;this.timeout=lockTimeout*1e3}setTimeout(timeout){this.timeout=timeout*1e3}createTid(){return DEBUG_MODE?++this._lastTid:acebase_core_1.ID.generate()}_allowLock(path,tid,forWriting){const conflict=this._locks.find((otherLock=>otherLock.tid!==tid&&otherLock.state===exports.LOCK_STATE.LOCKED&&(forWriting||otherLock.forWriting)));return{allow:!conflict,conflict:conflict}}quit(){return new Promise((resolve=>{if(this._locks.length===0){return resolve()}this._quit=resolve}))}_rejectLock(lock,err){this._locks.splice(this._locks.indexOf(lock),1);clearTimeout(lock.timeout);try{lock.reject(err)}catch(err){console.error(`Unhandled promise rejection:`,err)}}_processLockQueue(){if(this._quit){const quitError=new Error("Quitting");this._locks.filter((lock=>lock.state===exports.LOCK_STATE.PENDING)).forEach((lock=>this._rejectLock(lock,quitError)));if(this._locks.length===0){this._quit()}}const pending=this._locks.filter((lock=>lock.state===exports.LOCK_STATE.PENDING)).sort(((a,b)=>{if(a.priority&&!b.priority){return-1}else if(!a.priority&&b.priority){return 1}return a.requested-b.requested}));pending.forEach((lock=>{const check=this._allowLock(lock.path,lock.tid,lock.forWriting);lock.waitingFor=check.conflict||null;if(check.allow){this.lock(lock).then(lock.resolve).catch((err=>this._rejectLock(lock,err)))}}))}async lock(path,tid,forWriting=true,comment="",options={withPriority:false,noTimeout:false}){let lock,proceed;if(path instanceof NodeLock){lock=path;proceed=true}else if(this._locks.findIndex((l=>l.tid===tid&&l.state===exports.LOCK_STATE.EXPIRED))>=0){throw new Error(`lock on tid ${tid} has expired, not allowed to continue`)}else if(this._quit&&!options.withPriority){throw new Error(`Quitting`)}else{DEBUG_MODE&&console.error(`${forWriting?"write":"read"} lock requested on "${path}" by tid ${tid} (${comment})`);lock=new NodeLock(this,path,tid,forWriting,options.withPriority===true);lock.comment=comment;this._locks.push(lock);const check=this._allowLock(path,tid,forWriting);lock.waitingFor=check.conflict||null;proceed=check.allow}if(proceed){DEBUG_MODE&&console.error(`${lock.forWriting?"write":"read"} lock ALLOWED on "${lock.path}" by tid ${lock.tid} (${lock.comment})`);lock.state=exports.LOCK_STATE.LOCKED;if(typeof lock.granted==="number"){}else{lock.granted=Date.now();if(options.noTimeout!==true){lock.expires=Date.now()+this.timeout;let timeoutCount=0;const timeoutHandler=()=>{if(lock.state!==exports.LOCK_STATE.LOCKED){return}timeoutCount++;if(timeoutCount<=3){this.debug.warn(`${lock.forWriting?"write":"read"} lock on path "/${lock.path}" by tid ${lock.tid} (${lock.comment}) is taking a long time to complete [${timeoutCount}]`);lock.timeout=setTimeout(timeoutHandler,this.timeout/4);return}this.debug.error(`lock :: ${lock.forWriting?"write":"read"} lock on path "/${lock.path}" by tid ${lock.tid} (${lock.comment}) took too long`);lock.state=exports.LOCK_STATE.EXPIRED;this._processLockQueue()};lock.timeout=setTimeout(timeoutHandler,this.timeout/4)}}return lock}else{(0,assert_1.assert)(lock.state===exports.LOCK_STATE.PENDING);return new Promise(((resolve,reject)=>{lock.resolve=resolve;lock.reject=reject}))}}unlock(lockOrId,comment,processQueue=true){let lock,i;if(lockOrId instanceof NodeLock){lock=lockOrId;i=this._locks.indexOf(lock)}else{const id=lockOrId;i=this._locks.findIndex((l=>l.id===id));lock=this._locks[i]}if(i<0){const msg=`lock on "/${lock.path}" for tid ${lock.tid} wasn't found; ${comment}`;throw new Error(msg)}lock.state=exports.LOCK_STATE.DONE;clearTimeout(lock.timeout);this._locks.splice(i,1);DEBUG_MODE&&console.error(`${lock.forWriting?"write":"read"} lock RELEASED on "${lock.path}" by tid ${lock.tid}`);processQueue&&this._processLockQueue();return lock}list(){return this._locks||[]}isAllowed(path,tid,forWriting){return this._allowLock(path,tid,forWriting).allow}}exports.NodeLocker=NodeLocker;let lastid=0;class NodeLock{static get LOCK_STATE(){return exports.LOCK_STATE}constructor(locker,path,tid,forWriting,priority=false){this.locker=locker;this.path=path;this.tid=tid;this.forWriting=forWriting;this.priority=priority;this.state=exports.LOCK_STATE.PENDING;this.requested=Date.now();this.comment="";this.waitingFor=null;this.id=++lastid;this.history=[]}async release(comment){this.history.push({action:"release",path:this.path,forWriting:this.forWriting,comment:comment});return this.locker.unlock(this,comment||this.comment)}async moveToParent(){const parentPath=acebase_core_1.PathInfo.get(this.path).parentPath;const allowed=this.locker.isAllowed(parentPath,this.tid,this.forWriting);if(allowed){DEBUG_MODE&&console.error(`moveToParent ALLOWED for ${this.forWriting?"write":"read"} lock on "${this.path}" by tid ${this.tid} (${this.comment})`);this.history.push({path:this.path,forWriting:this.forWriting,action:"moving to parent"});this.waitingFor=null;this.path=parentPath;return this}else{DEBUG_MODE&&console.error(`moveToParent QUEUED for ${this.forWriting?"write":"read"} lock on "${this.path}" by tid ${this.tid} (${this.comment})`);this.locker.unlock(this,`moveLockToParent: ${this.comment}`,false);const newLock=await this.locker.lock(parentPath,this.tid,this.forWriting,this.comment,{withPriority:true});DEBUG_MODE&&console.error(`QUEUED moveToParent ALLOWED for ${this.forWriting?"write":"read"} lock on "${this.path}" by tid ${this.tid} (${this.comment})`);newLock.history=this.history;newLock.history.push({path:this.path,forWriting:this.forWriting,action:"moving to parent through queue (priority)"});return newLock}}}exports.NodeLock=NodeLock},{"./assert":4,"acebase-core":43}],14:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.getValueType=exports.getNodeValueType=exports.getValueTypeName=exports.VALUE_TYPES=void 0;const acebase_core_1=require("acebase-core");const nodeValueTypes={OBJECT:1,ARRAY:2,NUMBER:3,BOOLEAN:4,STRING:5,BIGINT:7,DATETIME:6,BINARY:8,REFERENCE:9};exports.VALUE_TYPES=nodeValueTypes;function getValueTypeName(valueType){switch(valueType){case exports.VALUE_TYPES.ARRAY:return"array";case exports.VALUE_TYPES.BINARY:return"binary";case exports.VALUE_TYPES.BOOLEAN:return"boolean";case exports.VALUE_TYPES.DATETIME:return"date";case exports.VALUE_TYPES.NUMBER:return"number";case exports.VALUE_TYPES.OBJECT:return"object";case exports.VALUE_TYPES.REFERENCE:return"reference";case exports.VALUE_TYPES.STRING:return"string";case exports.VALUE_TYPES.BIGINT:return"bigint";default:"unknown"}}exports.getValueTypeName=getValueTypeName;function getNodeValueType(value){if(value instanceof Array){return exports.VALUE_TYPES.ARRAY}else if(value instanceof acebase_core_1.PathReference){return exports.VALUE_TYPES.REFERENCE}else if(value instanceof ArrayBuffer){return exports.VALUE_TYPES.BINARY}else if(typeof value==="string"){return exports.VALUE_TYPES.STRING}else if(typeof value==="object"){return exports.VALUE_TYPES.OBJECT}else if(typeof value==="bigint"){return exports.VALUE_TYPES.BIGINT}throw new Error(`Invalid value for standalone node: ${value}`)}exports.getNodeValueType=getNodeValueType;function getValueType(value){if(value instanceof Array){return exports.VALUE_TYPES.ARRAY}else if(value instanceof acebase_core_1.PathReference){return exports.VALUE_TYPES.REFERENCE}else if(value instanceof ArrayBuffer){return exports.VALUE_TYPES.BINARY}else if(value instanceof Date){return exports.VALUE_TYPES.DATETIME}else if(typeof value==="string"){return exports.VALUE_TYPES.STRING}else if(typeof value==="object"){return exports.VALUE_TYPES.OBJECT}else if(typeof value==="number"){return exports.VALUE_TYPES.NUMBER}else if(typeof value==="boolean"){return exports.VALUE_TYPES.BOOLEAN}else if(typeof value==="bigint"){return exports.VALUE_TYPES.BIGINT}throw new Error(`Unknown value type: ${value}`)}exports.getValueType=getValueType},{"acebase-core":43}],15:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.NotSupported=void 0;class NotSupported{constructor(context="browser"){throw new Error(`This feature is not supported in ${context} context`)}}exports.NotSupported=NotSupported},{}],16:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.pfs=void 0;class pfs{static get hasFileSystem(){return false}static get fs(){return null}}exports.pfs=pfs},{}],17:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.executeQuery=void 0;const acebase_core_1=require("acebase-core");const node_value_types_1=require("./node-value-types");const node_errors_1=require("./node-errors");const data_index_1=require("./data-index");const async_task_batch_1=require("./async-task-batch");const noop=()=>{};async function executeQuery(api,path,query,options={snapshots:false,include:undefined,exclude:undefined,child_objects:undefined,eventHandler:noop}){var _a,_b,_c,_d,_e,_f;if(typeof options!=="object"){options={}}if(typeof options.snapshots==="undefined"){options.snapshots=false}const context={};if((_a=api.storage.settings.transactions)===null||_a===void 0?void 0:_a.log){context.acebase_cursor=acebase_core_1.ID.generate()}const queryFilters=query.filters.map((f=>Object.assign({},f)));const querySort=query.order.map((s=>Object.assign({},s)));const sortMatches=matches=>{matches.sort(((a,b)=>{const compare=i=>{const o=querySort[i];const trailKeys=acebase_core_1.PathInfo.getPathKeys(typeof o.key==="number"?`[${o.key}]`:o.key);const left=trailKeys.reduce(((val,key)=>val!==null&&typeof val==="object"&&key in val?val[key]:null),a.val);const right=trailKeys.reduce(((val,key)=>val!==null&&typeof val==="object"&&key in val?val[key]:null),b.val);if(left===null){return right===null?0:o.ascending?-1:1}if(right===null){return o.ascending?1:-1}if(left==right){if(i<querySort.length-1){return compare(i+1)}else{return a.path<b.path?-1:1}}else if(left<right){return o.ascending?-1:1}return o.ascending?1:-1};return compare(0)}))};const loadResultsData=async(preResults,options)=>{if(preResults.length===0){return[]}const maxBatchSize=50;const batch=new async_task_batch_1.AsyncTaskBatch(maxBatchSize);const results=[];preResults.forEach((({path:path},index)=>batch.add((async()=>{const node=await api.storage.getNode(path,options);const val=node.value;if(val===null){api.storage.debug.warn(`Indexed result "/${path}" does not have a record!`);return}const result={path:path,val:val};if(stepsExecuted.sorted){results[index]=result}else{results.push(result);if(!stepsExecuted.skipped&&results.length>query.skip+Math.abs(query.take)){sortMatches(results);results.pop()}}}))));await batch.finish();return results};const pathInfo=acebase_core_1.PathInfo.get(path);const isWildcardPath=pathInfo.keys.some((key=>key==="*"||key.toString().startsWith("$")));const availableIndexes=api.storage.indexes.get(path);const usingIndexes=[];let stop=async()=>{};if(isWildcardPath){const vars=pathInfo.keys.filter((key=>typeof key==="string"&&key.startsWith("$")));const hasExplicitFilterValues=vars.length>0&&vars.every((v=>query.filters.some((f=>f.key===v&&["==","in"].includes(f.op)))));const isRealtime=typeof options.monitor==="object"&&[(_b=options.monitor)===null||_b===void 0?void 0:_b.add,(_c=options.monitor)===null||_c===void 0?void 0:_c.change,(_d=options.monitor)===null||_d===void 0?void 0:_d.remove].some((val=>val===true));if(hasExplicitFilterValues&&!isRealtime){const combinations=[];for(const v of vars){const filters=query.filters.filter((f=>f.key===v));const filterValues=filters.reduce(((values,f)=>{if(f.op==="=="){values.push(f.compare)}if(f.op==="in"){if(!(f.compare instanceof Array)){throw new Error(`compare argument for 'in' operator must be an Array`)}values.push(...f.compare)}return values}),[]);const prevCombinations=combinations.splice(0);filterValues.forEach((fv=>{if(prevCombinations.length===0){combinations.push({[v]:fv})}else{combinations.push(...prevCombinations.map((c=>Object.assign(Object.assign({},c),{[v]:fv}))))}}))}const filters=query.filters.filter((f=>!vars.includes(f.key)));const paths=combinations.map((vars=>acebase_core_1.PathInfo.get(acebase_core_1.PathInfo.getPathKeys(path).map((key=>{var _a;return(_a=vars[key])!==null&&_a!==void 0?_a:key}))).path));const loadData=query.order.length>0;const promises=paths.map((path=>{var _a;return executeQuery(api,path,{filters:filters,take:0,skip:0,order:[]},{snapshots:loadData,cache_mode:options.cache_mode,include:[...(_a=options.include)!==null&&_a!==void 0?_a:[],...query.order.map((o=>o.key))],exclude:options.exclude})}));const resultSets=await Promise.all(promises);let results=resultSets.reduce(((results,set)=>(results.push(...set.results),results)),[]);if(loadData){sortMatches(results)}if(query.skip>0){results.splice(0,query.skip)}if(query.take>0){results.splice(query.take)}if(options.snapshots&&(!loadData||((_e=options.include)===null||_e===void 0?void 0:_e.length)>0||((_f=options.exclude)===null||_f===void 0?void 0:_f.length)>0||!options.child_objects)){const{include:include,exclude:exclude,child_objects:child_objects}=options;results=await loadResultsData(results,{include:include,exclude:exclude,child_objects:child_objects})}return{results:results,context:null,stop:stop}}else if(availableIndexes.length===0){const err=new Error(`Query on wildcard path "/${path}" requires an index`);return Promise.reject(err)}if(queryFilters.length===0){const index=availableIndexes.filter((index=>index.type==="normal"))[0];queryFilters.push({key:index.key,op:"!=",compare:null})}}queryFilters.forEach((filter=>{if(filter.index){return}const indexesOnKey=availableIndexes.filter((index=>index.key===filter.key)).filter((index=>index.validOperators.includes(filter.op)));if(indexesOnKey.length>=1){const otherFilterKeys=queryFilters.filter((f=>f!==filter)).map((f=>f.key));const sortKeys=querySort.map((o=>o.key)).filter((key=>key!==filter.key));const beneficialIndexes=indexesOnKey.map((index=>{const availableKeys=index.includeKeys.concat(index.key);const forOtherFilters=availableKeys.filter((key=>otherFilterKeys.includes(key)));const forSorting=availableKeys.filter((key=>sortKeys.includes(key)));const forBoth=forOtherFilters.concat(forSorting.filter((index=>!forOtherFilters.includes(index))));const points={filters:forOtherFilters.length,sorting:forSorting.length*(query.take!==0?forSorting.length:1),both:forBoth.length*forBoth.length,get total(){return this.filters+this.sorting+this.both}};return{index:index,points:points.total,filterKeys:forOtherFilters,sortKeys:forSorting}}));beneficialIndexes.sort(((a,b)=>a.points>b.points?-1:1));const bestBenificialIndex=beneficialIndexes[0];filter.index=bestBenificialIndex.index;bestBenificialIndex.filterKeys.forEach((key=>{queryFilters.filter((f=>f!==filter&&f.key===key)).forEach((f=>{if(!data_index_1.DataIndex.validOperators.includes(f.op)){return}f.indexUsage="filter";f.index=bestBenificialIndex.index}))}));bestBenificialIndex.sortKeys.forEach((key=>{querySort.filter((s=>s.key===key)).forEach((s=>{s.index=bestBenificialIndex.index}))}))}if(filter.index){usingIndexes.push({index:filter.index,description:filter.index.description})}}));if(querySort.length>0&&query.take!==0&&queryFilters.length===0){querySort.forEach((sort=>{if(sort.index){return}sort.index=availableIndexes.filter((index=>index.key===sort.key)).find((index=>index.type==="normal"))}))}const indexDescriptions=usingIndexes.map((index=>index.description)).join(", ");usingIndexes.length>0&&api.storage.debug.log(`Using indexes for query: ${indexDescriptions}`);const tableScanFilters=queryFilters.filter((filter=>!filter.index));const specialOpsRegex=/^[a-z]+:/i;if(tableScanFilters.some((filter=>specialOpsRegex.test(filter.op)))){const f=tableScanFilters.find((filter=>specialOpsRegex.test(filter.op)));const err=new Error(`query contains operator "${f.op}" which requires a special index that was not found on path "${path}", key "${f.key}"`);return Promise.reject(err)}const allowedTableScanOperators=["<","<=","==","!=",">=",">","like","!like","in","!in","matches","!matches","between","!between","has","!has","contains","!contains","exists","!exists"];for(let i=0;i<tableScanFilters.length;i++){const f=tableScanFilters[i];if(!allowedTableScanOperators.includes(f.op)){return Promise.reject(new Error(`query contains unknown filter operator "${f.op}" on path "${path}", key "${f.key}"`))}}if(isWildcardPath&&tableScanFilters.length>0){const keys=tableScanFilters.reduce(((keys,f)=>{if(keys.indexOf(f.key)<0){keys.push(f.key)}return keys}),[]).map((key=>`"${key}"`));const err=new Error(`This wildcard path query on "/${path}" requires index(es) on key(s): ${keys.join(", ")}. Create the index(es) and retry`);return Promise.reject(err)}const indexScanPromises=[];queryFilters.forEach((filter=>{if(filter.index&&filter.indexUsage!=="filter"){let promise=filter.index.query(filter.op,filter.compare).then((results=>{var _a,_b;(_a=options.eventHandler)===null||_a===void 0?void 0:_a.call(options,{name:"stats",type:"index_query",source:filter.index.description,stats:results.stats});if(results.hints.length>0){(_b=options.eventHandler)===null||_b===void 0?void 0:_b.call(options,{name:"hints",type:"index_query",source:filter.index.description,hints:results.hints})}return results}));const resultFilters=queryFilters.filter((f=>f.index===filter.index&&f.indexUsage==="filter"));if(resultFilters.length>0){promise=promise.then((results=>{resultFilters.forEach((filter=>{const{key:key,op:op,index:index}=filter;let{compare:compare}=filter;if(typeof compare==="string"&&!index.caseSensitive){compare=compare.toLocaleLowerCase(index.textLocale)}results=results.filterMetadata(key,op,compare)}));return results}))}indexScanPromises.push(promise)}}));const stepsExecuted={filtered:queryFilters.length===0,skipped:query.skip===0,taken:query.take===0,sorted:querySort.length===0,preDataLoaded:false,dataLoaded:false};if(queryFilters.length===0&&query.take===0){api.storage.debug.warn(`Filterless queries must use .take to limit the results. Defaulting to 100 for query on path "${path}"`);query.take=100}if(querySort.length>0&&querySort[0].index){const sortIndex=querySort[0].index;const ascending=query.take<0?!querySort[0].ascending:querySort[0].ascending;if(queryFilters.length===0&&querySort.slice(1).every((s=>sortIndex.allMetadataKeys.includes(s.key)))){api.storage.debug.log(`Using index for sorting: ${sortIndex.description}`);const metadataSort=querySort.slice(1).map((s=>{s.index=sortIndex;return{key:s.key,ascending:s.ascending}}));const promise=sortIndex.take(query.skip,Math.abs(query.take),{ascending:ascending,metadataSort:metadataSort}).then((results=>{var _a,_b;(_a=options.eventHandler)===null||_a===void 0?void 0:_a.call(options,{name:"stats",type:"sort_index_take",source:sortIndex.description,stats:results.stats});if(results.hints.length>0){(_b=options.eventHandler)===null||_b===void 0?void 0:_b.call(options,{name:"hints",type:"sort_index_take",source:sortIndex.description,hints:results.hints})}return results}));indexScanPromises.push(promise);stepsExecuted.skipped=true;stepsExecuted.taken=true;stepsExecuted.sorted=true}}return Promise.all(indexScanPromises).then((async indexResultSets=>{let indexedResults=[];if(indexResultSets.length===1){const resultSet=indexResultSets[0];indexedResults=resultSet.map((match=>{const result={key:match.key,path:match.path,val:{[resultSet.filterKey]:match.value}};match.metadata&&Object.assign(result.val,match.metadata);return result}));stepsExecuted.filtered=true}else if(indexResultSets.length>1){indexResultSets.sort(((a,b)=>a.length<b.length?-1:1));const shortestSet=indexResultSets[0];const otherSets=indexResultSets.slice(1);indexedResults=shortestSet.reduce(((results,match)=>{const result={key:match.key,path:match.path,val:{[shortestSet.filterKey]:match.value}};const matchedInAllSets=otherSets.every((set=>set.findIndex((m=>m.path===match.path))>=0));if(matchedInAllSets){match.metadata&&Object.assign(result.val,match.metadata);otherSets.forEach((set=>{const otherResult=set.find((r=>r.path===result.path));result.val[set.filterKey]=otherResult.value;otherResult.metadata&&Object.assign(result.val,otherResult.metadata)}));results.push(result)}return results}),[]);stepsExecuted.filtered=true}if(isWildcardPath||indexScanPromises.length>0&&tableScanFilters.length===0){if(querySort.length===0||querySort.every((o=>o.index))){stepsExecuted.preDataLoaded=true;if(!stepsExecuted.sorted&&querySort.length>0){sortMatches(indexedResults)}stepsExecuted.sorted=true;if(!stepsExecuted.skipped&&query.skip>0){indexedResults=query.take<0?indexedResults.slice(0,-query.skip):indexedResults.slice(query.skip)}if(!stepsExecuted.taken&&query.take!==0){indexedResults=query.take<0?indexedResults.slice(query.take):indexedResults.slice(0,query.take)}stepsExecuted.skipped=true;stepsExecuted.taken=true;if(!options.snapshots){return indexedResults}const childOptions={include:options.include,exclude:options.exclude,child_objects:options.child_objects};return loadResultsData(indexedResults,childOptions).then((results=>{stepsExecuted.dataLoaded=true;return results}))}if(options.snapshots||!stepsExecuted.sorted){const loadPartialResults=querySort.length>0;const childOptions=loadPartialResults?{include:querySort.map((order=>order.key))}:{include:options.include,exclude:options.exclude,child_objects:options.child_objects};return loadResultsData(indexedResults,childOptions).then((results=>{if(querySort.length>0){sortMatches(results)}stepsExecuted.sorted=true;if(query.skip>0){results=query.take<0?results.slice(0,-query.skip):results.slice(query.skip)}if(query.take!==0){results=query.take<0?results.slice(query.take):results.slice(0,query.take)}stepsExecuted.skipped=true;stepsExecuted.taken=true;if(options.snapshots&&loadPartialResults){return loadResultsData(results,{include:options.include,exclude:options.exclude,child_objects:options.child_objects})}return results}))}else{return indexedResults}}let indexKeyFilter;if(indexedResults.length>0){indexKeyFilter=indexedResults.map((result=>result.key))}let matches=[];let preliminaryStop=false;const loadPartialData=querySort.length>0;const childOptions=loadPartialData?{include:querySort.map((order=>order.key))}:{include:options.include,exclude:options.exclude,child_objects:options.child_objects};const batch={promises:[],add(promise){this.promises.push(promise);if(this.promises.length>=1e3){return Promise.all(this.promises.splice(0)).then((_=>undefined))}}};try{await api.storage.getChildren(path,{keyFilter:indexKeyFilter,async:true}).next((child=>{if(child.type!==node_value_types_1.VALUE_TYPES.OBJECT){return}if(!child.address){return}if(preliminaryStop){return false}const matchNode=async()=>{const isMatch=await api.storage.matchNode(child.address.path,tableScanFilters);if(!isMatch){return}const childPath=child.address.path;let result;if(options.snapshots||querySort.length>0){const node=await api.storage.getNode(childPath,childOptions);result={path:childPath,val:node.value}}else{result={path:childPath}}matches.push(result);if(query.take!==0&&matches.length>Math.abs(query.take)+query.skip){if(querySort.length>0){sortMatches(matches)}else if(query.take>0){preliminaryStop=true}matches.pop()}};const p=batch.add(matchNode());if(p instanceof Promise){return p}}))}catch(reason){if(!(reason instanceof node_errors_1.NodeNotFoundError)){api.storage.debug.warn(`Error getting child stream: ${reason}`)}return[]}await Promise.all(batch.promises);stepsExecuted.preDataLoaded=loadPartialData;stepsExecuted.dataLoaded=!loadPartialData;if(querySort.length>0){sortMatches(matches)}stepsExecuted.sorted=true;if(query.skip>0){matches=query.take<0?matches.slice(0,-query.skip):matches.slice(query.skip)}stepsExecuted.skipped=true;if(query.take!==0){matches=query.take<0?matches.slice(query.take):matches.slice(0,query.take)}stepsExecuted.taken=true;if(!stepsExecuted.dataLoaded){matches=await loadResultsData(matches,{include:options.include,exclude:options.exclude,child_objects:options.child_objects});stepsExecuted.dataLoaded=true}return matches})).then((matches=>{if(!stepsExecuted.sorted&&querySort.length>0){sortMatches(matches)}if(!options.snapshots){matches=matches.map((match=>match.path))}if(!stepsExecuted.skipped&&query.skip>0){matches=query.take<0?matches.slice(0,-query.skip):matches.slice(query.skip)}if(!stepsExecuted.taken&&query.take!==0){matches=query.take<0?matches.slice(query.take):matches.slice(0,query.take)}if(options.monitor===true){options.monitor={add:true,change:true,remove:true}}if(typeof options.monitor==="object"&&(options.monitor.add||options.monitor.change||options.monitor.remove)){const monitor=options.monitor;const matchedPaths=options.snapshots?matches.map((match=>match.path)):matches.slice();const ref=api.db.ref(path);const removeMatch=path=>{const index=matchedPaths.indexOf(path);if(index<0){return}matchedPaths.splice(index,1)};const addMatch=path=>{if(matchedPaths.includes(path)){return}matchedPaths.push(path)};const stopMonitoring=()=>{api.unsubscribe(ref.path,"child_changed",childChangedCallback);api.unsubscribe(ref.path,"child_added",childAddedCallback);api.unsubscribe(ref.path,"notify_child_removed",childRemovedCallback)};stop=async()=>{stopMonitoring()};const childChangedCallback=async(err,path,newValue,oldValue)=>{const wasMatch=matchedPaths.includes(path);let keepMonitoring=true;const checkKeys=[];queryFilters.forEach((f=>!checkKeys.includes(f.key)&&checkKeys.push(f.key)));const seenKeys=[];typeof oldValue==="object"&&Object.keys(oldValue).forEach((key=>!seenKeys.includes(key)&&seenKeys.push(key)));typeof newValue==="object"&&Object.keys(newValue).forEach((key=>!seenKeys.includes(key)&&seenKeys.push(key)));const missingKeys=[];let isMatch=seenKeys.every((key=>{if(!checkKeys.includes(key)){return true}const filters=queryFilters.filter((filter=>filter.key===key));return filters.every((filter=>{var _a;if(((_a=filter.index)===null||_a===void 0?void 0:_a.textLocaleKey)&&!seenKeys.includes(filter.index.textLocaleKey)){missingKeys.push(filter.index.textLocaleKey);return true}else if(allowedTableScanOperators.includes(filter.op)){return api.storage.test(newValue[key],filter.op,filter.compare)}else{return filter.index.test(newValue,filter.op,filter.compare)}}))}));if(isMatch){missingKeys.push(...checkKeys.filter((key=>!seenKeys.includes(key))));if(!wasMatch&&missingKeys.length>0){const filterQueue=queryFilters.filter((f=>missingKeys.includes(f.key)));const simpleFilters=filterQueue.filter((f=>allowedTableScanOperators.includes(f.op)));const indexFilters=filterQueue.filter((f=>!allowedTableScanOperators.includes(f.op)));if(simpleFilters.length>0){isMatch=await api.storage.matchNode(path,simpleFilters)}if(isMatch&&indexFilters.length>0){const keysToLoad=indexFilters.reduce(((keys,filter)=>{if(!keys.includes(filter.key)){keys.push(filter.key)}if(filter.index instanceof data_index_1.FullTextIndex&&filter.index.config.localeKey&&!keys.includes(filter.index.config.localeKey)){keys.push(filter.index.config.localeKey)}return keys}),[]);const node=await api.storage.getNode(path,{include:keysToLoad});if(node.value===null){return false}isMatch=indexFilters.every((filter=>filter.index.test(node.value,filter.op,filter.compare)))}}}if(isMatch){if(!wasMatch){addMatch(path)}if(options.snapshots){const loadOptions={include:options.include,exclude:options.exclude,child_objects:options.child_objects};const node=await api.storage.getNode(path,loadOptions);newValue=node.value}if(wasMatch&&monitor.change){keepMonitoring=options.eventHandler({name:"change",path:path,value:newValue})!==false}else if(!wasMatch&&monitor.add){keepMonitoring=options.eventHandler({name:"add",path:path,value:newValue})!==false}}else if(wasMatch){removeMatch(path);if(monitor.remove){keepMonitoring=options.eventHandler({name:"remove",path:path,value:oldValue})!==false}}if(keepMonitoring===false){stopMonitoring()}};const childAddedCallback=(err,path,newValue)=>{const isMatch=queryFilters.every((filter=>{if(allowedTableScanOperators.includes(filter.op)){return api.storage.test(newValue[filter.key],filter.op,filter.compare)}else{return filter.index.test(newValue,filter.op,filter.compare)}}));let keepMonitoring=true;if(isMatch){addMatch(path);if(monitor.add){keepMonitoring=options.eventHandler({name:"add",path:path,value:options.snapshots?newValue:null})!==false}}if(keepMonitoring===false){stopMonitoring()}};const childRemovedCallback=(err,path,newValue,oldValue)=>{let keepMonitoring=true;removeMatch(path);if(monitor.remove){keepMonitoring=options.eventHandler({name:"remove",path:path,value:options.snapshots?oldValue:null})!==false}if(keepMonitoring===false){stopMonitoring()}};if(options.monitor.add||options.monitor.change||options.monitor.remove){api.subscribe(ref.path,"child_changed",childChangedCallback)}if(options.monitor.remove){api.subscribe(ref.path,"notify_child_removed",childRemovedCallback)}if(options.monitor.add){api.subscribe(ref.path,"child_added",childAddedCallback)}}return{results:matches,context:context,stop:stop}}))}exports.executeQuery=executeQuery},{"./async-task-batch":5,"./data-index":7,"./node-errors":11,"./node-value-types":14,"acebase-core":43}],18:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.AceBaseStorage=exports.AceBaseStorageSettings=void 0;const not_supported_1=require("../../not-supported");class AceBaseStorageSettings extends not_supported_1.NotSupported{}exports.AceBaseStorageSettings=AceBaseStorageSettings;class AceBaseStorage extends not_supported_1.NotSupported{}exports.AceBaseStorage=AceBaseStorage},{"../../not-supported":15}],19:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.createIndex=void 0;const acebase_core_1=require("acebase-core");const data_index_1=require("../data-index");const promise_fs_1=require("../promise-fs");async function createIndex(context,path,key,options){if(!context.storage.indexes.supported){throw new Error("Indexes are not supported in current environment because it requires Node.js fs")}const{ipc:ipc,debug:debug,indexes:indexes,storage:storage}=context;const rebuild=options&&options.rebuild===true;const indexType=options&&options.type||"normal";let includeKeys=options&&options.include||[];if(typeof includeKeys==="string"){includeKeys=[includeKeys]}const existingIndex=indexes.find((index=>index.path===path&&index.key===key&&index.type===indexType&&index.includeKeys.length===includeKeys.length&&index.includeKeys.every(((key,index)=>includeKeys[index]===key))));if(existingIndex&&options.config){existingIndex.config=options.config}if(existingIndex&&rebuild!==true){debug.log(`Index on "/${path}/*/${key}" already exists`.colorize(acebase_core_1.ColorStyle.inverse));return existingIndex}if(!ipc.isMaster){const result=await ipc.sendRequest({type:"index.create",path:path,key:key,options:options});if(result.ok){return storage.indexes.add(result.fileName)}throw new Error(result.reason)}await promise_fs_1.pfs.mkdir(`${storage.settings.path}/${storage.name}.acebase`).catch((err=>{if(err.code!=="EEXIST"){throw err}}));const index=existingIndex||(()=>{const{include:include,caseSensitive:caseSensitive,textLocale:textLocale,textLocaleKey:textLocaleKey}=options;const indexOptions={include:include,caseSensitive:caseSensitive,textLocale:textLocale,textLocaleKey:textLocaleKey};switch(indexType){case"array":return new data_index_1.ArrayIndex(storage,path,key,Object.assign({},indexOptions));case"fulltext":return new data_index_1.FullTextIndex(storage,path,key,Object.assign(Object.assign({},indexOptions),{config:options.config}));case"geo":return new data_index_1.GeoIndex(storage,path,key,Object.assign({},indexOptions));default:return new data_index_1.DataIndex(storage,path,key,Object.assign({},indexOptions))}})();if(!existingIndex){indexes.push(index)}try{await index.build()}catch(err){context.debug.error(`Index build on "/${path}/*/${key}" failed: ${err.message} (code: ${err.code})`.colorize(acebase_core_1.ColorStyle.red));if(!existingIndex){indexes.splice(indexes.indexOf(index),1)}throw err}ipc.sendNotification({type:"index.created",fileName:index.fileName,path:path,key:key,options:options});return index}exports.createIndex=createIndex},{"../data-index":7,"../promise-fs":16,"acebase-core":43}],20:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.CustomStorageHelpers=void 0;const acebase_core_1=require("acebase-core");class CustomStorageHelpers{static ChildPathsSql(path,columnName="path"){const where=path===""?`${columnName} <> '' AND ${columnName} NOT LIKE '%/%'`:`(${columnName} LIKE '${path}/%' OR ${columnName} LIKE '${path}[%') AND ${columnName} NOT LIKE '${path}/%/%' AND ${columnName} NOT LIKE '${path}[%]/%' AND ${columnName} NOT LIKE '${path}[%][%'`;return where}static ChildPathsRegex(path){return new RegExp(`^${path}(?:/[^/[]+|\\[[0-9]+\\])$`)}static DescendantPathsSql(path,columnName="path"){const where=path===""?`${columnName} <> ''`:`${columnName} LIKE '${path}/%' OR ${columnName} LIKE '${path}[%'`;return where}static DescendantPathsRegex(path){return new RegExp(`^${path}(?:/[^/[]+|\\[[0-9]+\\])`)}static get PathInfo(){return acebase_core_1.PathInfo}}exports.CustomStorageHelpers=CustomStorageHelpers},{"acebase-core":43}],21:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.CustomStorage=exports.CustomStorageNodeInfo=exports.CustomStorageNodeAddress=exports.CustomStorageSettings=exports.CustomStorageTransaction=exports.ICustomStorageNode=exports.ICustomStorageNodeMetaData=exports.CustomStorageHelpers=void 0;const acebase_core_1=require("acebase-core");const{compareValues:compareValues}=acebase_core_1.Utils;const node_info_1=require("../../node-info");const node_lock_1=require("../../node-lock");const node_value_types_1=require("../../node-value-types");const node_errors_1=require("../../node-errors");const index_1=require("../index");const helpers_1=require("./helpers");const node_address_1=require("../../node-address");const assert_1=require("../../assert");var helpers_2=require("./helpers");Object.defineProperty(exports,"CustomStorageHelpers",{enumerable:true,get:function(){return helpers_2.CustomStorageHelpers}});class ICustomStorageNodeMetaData{constructor(){this.revision="";this.revision_nr=0;this.created=0;this.modified=0;this.type=0}}exports.ICustomStorageNodeMetaData=ICustomStorageNodeMetaData;class ICustomStorageNode extends ICustomStorageNodeMetaData{constructor(){super();this.value=null}}exports.ICustomStorageNode=ICustomStorageNode;class CustomStorageTransaction{constructor(target){this.production=false;this.target={get originalPath(){return target.path},path:target.path,get write(){return target.write}};this.id=acebase_core_1.ID.generate()}async getChildCount(path){let childCount=0;await this.childrenOf(path,{metadata:false,value:false},(()=>{childCount++;return false}));return childCount}async getMultiple(paths){const map=new Map;await Promise.all(paths.map((path=>this.get(path).then((val=>map.set(path,val))))));return map}async setMultiple(nodes){await Promise.all(nodes.map((({path:path,node:node})=>this.set(path,node))))}async removeMultiple(paths){await Promise.all(paths.map((path=>this.remove(path))))}async commit(){throw new Error(`CustomStorageTransaction.rollback must be overridden by subclass`)}async moveToParentPath(targetPath){const currentPath=this._lock&&this._lock.path||this.target.path;if(currentPath===targetPath){return targetPath}const pathInfo=helpers_1.CustomStorageHelpers.PathInfo.get(targetPath);if(pathInfo.isParentOf(currentPath)){if(this._lock){this._lock=await this._lock.moveToParent()}}else{throw new Error(`Locking issue. Locked path "${this._lock.path}" is not a child/descendant of "${targetPath}"`)}this.target.path=targetPath;return targetPath}}exports.CustomStorageTransaction=CustomStorageTransaction;class CustomStorageSettings extends index_1.StorageSettings{constructor(settings){super(settings);this.locking=true;if(typeof settings!=="object"){throw new Error("settings missing")}if(typeof settings.ready!=="function"){throw new Error(`ready must be a function`)}if(typeof settings.getTransaction!=="function"){throw new Error(`getTransaction must be a function`)}this.name=settings.name;this.locking=settings.locking!==false;if(this.locking){this.lockTimeout=typeof settings.lockTimeout==="number"?settings.lockTimeout:120}this.ready=settings.ready;const useLocking=this.locking;const nodeLocker=useLocking?new node_lock_1.NodeLocker(console,this.lockTimeout):null;this.getTransaction=async({path:path,write:write})=>{const transaction=await settings.getTransaction({path:path,write:write});(0,assert_1.assert)(typeof transaction.id==="string",`transaction id not set`);const rollback=transaction.rollback;const commit=transaction.commit;transaction.commit=async()=>{const ret=await commit.call(transaction);if(useLocking){await transaction._lock.release("commit")}return ret};transaction.rollback=async reason=>{const ret=await rollback.call(transaction,reason);if(useLocking){await transaction._lock.release("rollback")}return ret};if(useLocking){transaction._lock=await nodeLocker.lock(path,transaction.id,write,`${this.name}::getTransaction`)}return transaction}}}exports.CustomStorageSettings=CustomStorageSettings;class CustomStorageNodeAddress{constructor(containerPath){this.path=containerPath}}exports.CustomStorageNodeAddress=CustomStorageNodeAddress;class CustomStorageNodeInfo extends node_info_1.NodeInfo{constructor(info){super(info);this.revision=info.revision;this.revision_nr=info.revision_nr;this.created=info.created;this.modified=info.modified}}exports.CustomStorageNodeInfo=CustomStorageNodeInfo;class CustomStorage extends index_1.Storage{constructor(dbname,settings,env){super(dbname,settings,env);this._customImplementation=settings;this._init()}async _init(){this.debug.log(`Database "${this.name}" details:`.colorize(acebase_core_1.ColorStyle.dim));this.debug.log(`- Type: CustomStorage`.colorize(acebase_core_1.ColorStyle.dim));this.debug.log(`- Path: ${this.settings.path}`.colorize(acebase_core_1.ColorStyle.dim));this.debug.log(`- Max inline value size: ${this.settings.maxInlineValueSize}`.colorize(acebase_core_1.ColorStyle.dim));this.debug.log(`- Autoremove undefined props: ${this.settings.removeVoidProperties}`.colorize(acebase_core_1.ColorStyle.dim));await this._customImplementation.ready();const transaction=await this._customImplementation.getTransaction({path:"",write:true});const info=await this.getNodeInfo("",{transaction:transaction});if(!info.exists){await this._writeNode("",{},{transaction:transaction})}await transaction.commit();if(this.indexes.supported){await this.indexes.load()}this.emit("ready")}throwImplementationError(message){throw new Error(`CustomStorage "${this._customImplementation.name}" ${message}`)}_storeNode(path,node,options){const getTypedChildValue=val=>{if(val===null){throw new Error(`Not allowed to store null values. remove the property`)}else if(["string","number","boolean"].includes(typeof val)){return val}else if(val instanceof Date){return{type:node_value_types_1.VALUE_TYPES.DATETIME,value:val.getTime()}}else if(val instanceof acebase_core_1.PathReference){return{type:node_value_types_1.VALUE_TYPES.REFERENCE,value:val.path}}else if(val instanceof ArrayBuffer){return{type:node_value_types_1.VALUE_TYPES.BINARY,value:acebase_core_1.ascii85.encode(val)}}else if(typeof val==="object"){(0,assert_1.assert)(Object.keys(val).length===0,"child object stored in parent can only be empty");return val}};const unprocessed=`Caller should have pre-processed the value by converting it to a string`;if(node.type===node_value_types_1.VALUE_TYPES.ARRAY&&node.value instanceof Array){console.warn(`Unprocessed array. ${unprocessed}`);const obj={};for(let i=0;i<node.value.length;i++){obj[i]=node.value[i]}node.value=obj}if(node.type===node_value_types_1.VALUE_TYPES.BINARY&&typeof node.value!=="string"){console.warn(`Unprocessed binary value. ${unprocessed}`);node.value=acebase_core_1.ascii85.encode(node.value)}if(node.type===node_value_types_1.VALUE_TYPES.REFERENCE&&node.value instanceof acebase_core_1.PathReference){console.warn(`Unprocessed path reference. ${unprocessed}`);node.value=node.value.path}if([node_value_types_1.VALUE_TYPES.OBJECT,node_value_types_1.VALUE_TYPES.ARRAY].includes(node.type)){const original=node.value;node.value={};Object.keys(original).forEach((key=>{node.value[key]=getTypedChildValue(original[key])}))}return options.transaction.set(path,node)}_processReadNodeValue(node){const getTypedChildValue=val=>{if(val.type===node_value_types_1.VALUE_TYPES.BINARY){return acebase_core_1.ascii85.decode(val.value)}else if(val.type===node_value_types_1.VALUE_TYPES.DATETIME){return new Date(val.value)}else if(val.type===node_value_types_1.VALUE_TYPES.REFERENCE){return new acebase_core_1.PathReference(val.value)}else{throw new Error(`Unhandled child value type ${val.type}`)}};switch(node.type){case node_value_types_1.VALUE_TYPES.ARRAY:case node_value_types_1.VALUE_TYPES.OBJECT:{const obj=node.value;Object.keys(obj).forEach((key=>{const item=obj[key];if(typeof item==="object"&&"type"in item){obj[key]=getTypedChildValue(item)}}));node.value=obj;break}case node_value_types_1.VALUE_TYPES.BINARY:{node.value=acebase_core_1.ascii85.decode(node.value);break}case node_value_types_1.VALUE_TYPES.REFERENCE:{node.value=new acebase_core_1.PathReference(node.value);break}case node_value_types_1.VALUE_TYPES.STRING:{break}default:throw new Error(`Invalid standalone record value type`)}}async _readNode(path,options){const node=await options.transaction.get(path);if(node===null){return null}if(typeof node!=="object"){this.throwImplementationError(`transaction.get must return an ICustomStorageNode object. Use JSON.parse if your set function stored it as a string`)}this._processReadNodeValue(node);return node}_getTypeFromStoredValue(val){let type;if(typeof val==="string"){type=node_value_types_1.VALUE_TYPES.STRING}else if(typeof val==="number"){type=node_value_types_1.VALUE_TYPES.NUMBER}else if(typeof val==="boolean"){type=node_value_types_1.VALUE_TYPES.BOOLEAN}else if(val instanceof Array){type=node_value_types_1.VALUE_TYPES.ARRAY}else if(typeof val==="object"){if("type"in val){const serialized=val;type=serialized.type;val=serialized.value;if(type===node_value_types_1.VALUE_TYPES.DATETIME){val=new Date(val)}else if(type===node_value_types_1.VALUE_TYPES.REFERENCE){val=new acebase_core_1.PathReference(val)}}else{type=node_value_types_1.VALUE_TYPES.OBJECT}}else{throw new Error(`Unknown value type`)}return{type:type,value:val}}async _writeNode(path,value,options){if(!options.merge&&this.valueFitsInline(value)&&path!==""){throw new Error(`invalid value to store in its own node`)}else if(path===""&&(typeof value!=="object"||value instanceof Array)){throw new Error(`Invalid root node value. Must be an object`)}if(typeof options.diff==="undefined"&&typeof options.currentValue!=="undefined"){const diff=compareValues(options.currentValue,value);if(options.merge&&typeof diff==="object"){diff.removed=diff.removed.filter((key=>value[key]===null))}options.diff=diff}if(options.diff==="identical"){return}const transaction=options.transaction;const currentRow=options.currentValue===null?null:await this._readNode(path,{transaction:transaction});if(options.merge&&currentRow){if(currentRow.type===node_value_types_1.VALUE_TYPES.ARRAY&&!(value instanceof Array)&&typeof value==="object"&&Object.keys(value).some((key=>isNaN(parseInt(key))))){throw new Error(`Cannot merge existing array of path "${path}" with an object`)}if(value instanceof Array&&currentRow.type!==node_value_types_1.VALUE_TYPES.ARRAY){throw new Error(`Cannot merge existing object of path "${path}" with an array`)}}const revision=options.revision||acebase_core_1.ID.generate();const mainNode={type:currentRow&&currentRow.type===node_value_types_1.VALUE_TYPES.ARRAY?node_value_types_1.VALUE_TYPES.ARRAY:node_value_types_1.VALUE_TYPES.OBJECT,value:{}};const childNodeValues={};if(value instanceof Array){mainNode.type=node_value_types_1.VALUE_TYPES.ARRAY;const obj={};for(let i=0;i<value.length;i++){obj[i]=value[i]}value=obj}else if(value instanceof acebase_core_1.PathReference){mainNode.type=node_value_types_1.VALUE_TYPES.REFERENCE;mainNode.value=value.path}else if(value instanceof ArrayBuffer){mainNode.type=node_value_types_1.VALUE_TYPES.BINARY;mainNode.value=acebase_core_1.ascii85.encode(value)}else if(typeof value==="string"){mainNode.type=node_value_types_1.VALUE_TYPES.STRING;mainNode.value=value}const currentIsObjectOrArray=currentRow?[node_value_types_1.VALUE_TYPES.OBJECT,node_value_types_1.VALUE_TYPES.ARRAY].includes(currentRow.type):false;const newIsObjectOrArray=[node_value_types_1.VALUE_TYPES.OBJECT,node_value_types_1.VALUE_TYPES.ARRAY].includes(mainNode.type);const children={current:[],new:[]};let currentObject=null;if(currentIsObjectOrArray){currentObject=currentRow.value;children.current=Object.keys(currentObject);if(newIsObjectOrArray){mainNode.value=currentObject}}if(newIsObjectOrArray){if(!options.merge){Object.keys(mainNode.value).forEach((key=>{if(!(key in value)){value[key]=null}}))}Object.keys(value).forEach((key=>{const val=value[key];delete mainNode.value[key];if(val===null){return}else if(typeof val==="undefined"){if(this.settings.removeVoidProperties===true){delete value[key];return}else{throw new Error(`Property "${key}" has invalid value. Cannot store undefined values. Set removeVoidProperties option to true to automatically remove undefined properties`)}}if(this.valueFitsInline(val)){mainNode.value[key]=val}else{childNodeValues[key]=val}}))}const isArray=mainNode.type===node_value_types_1.VALUE_TYPES.ARRAY;if(currentRow){this.debug.log(`Node "/${path}" is being ${options.merge?"updated":"overwritten"}`.colorize(acebase_core_1.ColorStyle.cyan));if(currentIsObjectOrArray||newIsObjectOrArray){const pathInfo=acebase_core_1.PathInfo.get(path);const keys=[];let checkExecuted=false;const includeChildCheck=childPath=>{checkExecuted=true;if(!transaction.production&&!pathInfo.isParentOf(childPath)){this.throwImplementationError(`"${childPath}" is not a child of "${path}" - childrenOf must only check and return paths that are children`)}return true};const addChildPath=childPath=>{if(!checkExecuted){this.throwImplementationError(`childrenOf did not call checkCallback before addCallback`)}const key=acebase_core_1.PathInfo.get(childPath).key;keys.push(key.toString());return true};await transaction.childrenOf(path,{metadata:false,value:false},includeChildCheck,addChildPath);children.current=children.current.concat(keys);if(newIsObjectOrArray){if(options&&options.merge){children.new=children.current.slice()}Object.keys(value).forEach((key=>{if(!children.new.includes(key)){children.new.push(key)}}))}const changes={insert:children.new.filter((key=>!children.current.includes(key))),update:[],delete:options&&options.merge?Object.keys(value).filter((key=>value[key]===null)):children.current.filter((key=>!children.new.includes(key)))};changes.update=children.new.filter((key=>children.current.includes(key)&&!changes.delete.includes(key)));if(isArray&&options.merge&&(changes.insert.length>0||changes.delete.length>0)){const newArrayKeys=changes.update.concat(changes.insert);const isExhaustive=newArrayKeys.every(((k,index,arr)=>arr.includes(index.toString())));if(!isExhaustive){throw new Error(`Elements cannot be inserted beyond, or removed before the end of an array. Rewrite the whole array at path "${path}" or change your schema to use an object collection instead`)}}const writePromises=Object.keys(childNodeValues).map((key=>{const keyOrIndex=isArray?parseInt(key):key;const childDiff=typeof options.diff==="object"?options.diff.forChild(keyOrIndex):undefined;if(childDiff==="identical"){return}const childPath=pathInfo.childPath(keyOrIndex);const childValue=childNodeValues[keyOrIndex];const currentChildValue=typeof options.currentValue==="undefined"?undefined:options.currentValue!==null&&typeof options.currentValue==="object"&&keyOrIndex in options.currentValue?options.currentValue[keyOrIndex]:null;return this._writeNode(childPath,childValue,{transaction:transaction,revision:revision,merge:false,currentValue:currentChildValue,diff:childDiff})}));const movingNodes=newIsObjectOrArray?keys.filter((key=>key in mainNode.value)):[];const deleteDedicatedKeys=changes.delete.concat(movingNodes);const deletePromises=deleteDedicatedKeys.map((key=>{const keyOrIndex=isArray?parseInt(key):key;const childPath=pathInfo.childPath(keyOrIndex);return this._deleteNode(childPath,{transaction:transaction})}));const promises=writePromises.concat(deletePromises);await Promise.all(promises)}const p=this._storeNode(path,{type:mainNode.type,value:mainNode.value,revision:currentRow.revision,revision_nr:currentRow.revision_nr+1,created:currentRow.created,modified:Date.now()},{transaction:transaction});if(p instanceof Promise){return await p}}else{this.debug.log(`Node "/${path}" is being created`.colorize(acebase_core_1.ColorStyle.cyan));if(isArray){const arrayKeys=Object.keys(mainNode.value).concat(Object.keys(childNodeValues));const isExhaustive=arrayKeys.every(((k,index,arr)=>arr.includes(index.toString())));if(!isExhaustive){throw new Error(`Cannot store arrays with missing entries`)}}const promises=Object.keys(childNodeValues).map((key=>{const keyOrIndex=isArray?parseInt(key):key;const childPath=acebase_core_1.PathInfo.getChildPath(path,keyOrIndex);const childValue=childNodeValues[keyOrIndex];return this._writeNode(childPath,childValue,{transaction:transaction,revision:revision,merge:false,currentValue:null})}));const p=this._storeNode(path,{type:mainNode.type,value:mainNode.value,revision:revision,revision_nr:1,created:Date.now(),modified:Date.now()},{transaction:transaction});if(p instanceof Promise){promises.push(p)}await Promise.all(promises)}}async _deleteNode(path,options){const pathInfo=acebase_core_1.PathInfo.get(path);this.debug.log(`Node "/${path}" is being deleted`.colorize(acebase_core_1.ColorStyle.cyan));const deletePaths=[path];let checkExecuted=false;const includeDescendantCheck=descPath=>{checkExecuted=true;if(!transaction.production&&!pathInfo.isAncestorOf(descPath)){this.throwImplementationError(`"${descPath}" is not a descendant of "${path}" - descendantsOf must only check and return paths that are descendants`)}return true};const addDescendant=descPath=>{if(!checkExecuted){this.throwImplementationError(`descendantsOf did not call checkCallback before addCallback`)}deletePaths.push(descPath);return true};const transaction=options.transaction;await transaction.descendantsOf(path,{metadata:false,value:false},includeDescendantCheck,addDescendant);this.debug.log(`Nodes ${deletePaths.map((p=>`"/${p}"`)).join(",")} are being deleted`.colorize(acebase_core_1.ColorStyle.cyan));return transaction.removeMultiple(deletePaths)}getChildren(path,options={}){let callback;const generator={next(valueCallback){callback=valueCallback;return start()}};const start=async()=>{const transaction=options.transaction||await this._customImplementation.getTransaction({path:path,write:false});try{let canceled=false;await(async()=>{const node=await this._readNode(path,{transaction:transaction});if(!node){throw new node_errors_1.NodeNotFoundError(`Node "/${path}" does not exist`)}if(![node_value_types_1.VALUE_TYPES.OBJECT,node_value_types_1.VALUE_TYPES.ARRAY].includes(node.type)){return}const isArray=node.type===node_value_types_1.VALUE_TYPES.ARRAY;const value=node.value;let keys=Object.keys(value).map((key=>isArray?parseInt(key):key));if(options.keyFilter){keys=keys.filter((key=>options.keyFilter.includes(key)))}const pathInfo=acebase_core_1.PathInfo.get(path);keys.length>0&&keys.every((key=>{const child=this._getTypeFromStoredValue(value[key]);const info=new CustomStorageNodeInfo({path:pathInfo.childPath(key),key:isArray?null:key,index:isArray?key:null,type:child.type,address:null,exists:true,value:child.value,revision:node.revision,revision_nr:node.revision_nr,created:new Date(node.created),modified:new Date(node.modified)});canceled=callback(info)===false;return!canceled}));if(canceled){return}let checkExecuted=false;const includeChildCheck=childPath=>{checkExecuted=true;if(!transaction.production&&!pathInfo.isParentOf(childPath)){this.throwImplementationError(`"${childPath}" is not a child of "${path}" - childrenOf must only check and return paths that are children`)}if(options.keyFilter){const key=acebase_core_1.PathInfo.get(childPath).key;return options.keyFilter.includes(key)}return true};const addChildNode=(childPath,node)=>{if(!checkExecuted){this.throwImplementationError(`childrenOf did not call checkCallback before addCallback`)}const key=acebase_core_1.PathInfo.get(childPath).key;const info=new CustomStorageNodeInfo({path:childPath,type:node.type,key:isArray?null:key,index:isArray?key:null,address:new node_address_1.NodeAddress(childPath),exists:true,value:null,revision:node.revision,revision_nr:node.revision_nr,created:new Date(node.created),modified:new Date(node.modified)});canceled=callback(info)===false;return!canceled};await transaction.childrenOf(path,{metadata:true,value:false},includeChildCheck,addChildNode)})();if(!options.transaction){await transaction.commit()}return canceled}catch(err){if(!options.transaction){await transaction.rollback(err)}throw err}};return generator}async getNode(path,options){options=options||{};const transaction=options.transaction||await this._customImplementation.getTransaction({path:path,write:false});try{const node=await(async()=>{const filtered=options.include&&options.include.length>0||options.exclude&&options.exclude.length>0||options.child_objects===false;const pathInfo=acebase_core_1.PathInfo.get(path);const targetNode=await this._readNode(path,{transaction:transaction});if(!targetNode){if(path===""){return{value:null}}const lockPath=await transaction.moveToParentPath(pathInfo.parentPath);(0,assert_1.assert)(lockPath===pathInfo.parentPath,`transaction.moveToParentPath() did not move to the right parent path of "${path}"`);const parentNode=await this._readNode(pathInfo.parentPath,{transaction:transaction});if(parentNode&&[node_value_types_1.VALUE_TYPES.OBJECT,node_value_types_1.VALUE_TYPES.ARRAY].includes(parentNode.type)&&pathInfo.key in parentNode.value){const childValueInfo=this._getTypeFromStoredValue(parentNode.value[pathInfo.key]);return{revision:parentNode.revision,revision_nr:parentNode.revision_nr,created:parentNode.created,modified:parentNode.modified,type:childValueInfo.type,value:childValueInfo.value}}return{value:null}}const isArray=targetNode.type===node_value_types_1.VALUE_TYPES.ARRAY;const convertFilterArray=arr=>{const isNumber=key=>/^[0-9]+$/.test(key);return arr.map((path=>acebase_core_1.PathInfo.get(isArray&&isNumber(path)?`[${path}]`:path)))};const includeFilter=options.include?convertFilterArray(options.include):[];const excludeFilter=options.exclude?convertFilterArray(options.exclude):[];const applyFiltersOnInlineData=(descPath,node)=>{if([node_value_types_1.VALUE_TYPES.OBJECT,node_value_types_1.VALUE_TYPES.ARRAY].includes(node.type)&&includeFilter.length>0){const trailKeys=acebase_core_1.PathInfo.getPathKeys(descPath).slice(pathInfo.keys.length);const checkPathInfo=new acebase_core_1.PathInfo(trailKeys);const remove=[];const includes=includeFilter.filter((info=>info.isDescendantOf(checkPathInfo)));if(includes.length>0){const isArray=node.type===node_value_types_1.VALUE_TYPES.ARRAY;remove.push(...Object.keys(node.value).map((key=>isArray?+key:key)));for(const info of includes){const targetProp=info.keys[trailKeys.length];if(typeof targetProp==="string"&&(targetProp==="*"||targetProp.startsWith("$"))){remove.splice(0);break}const index=remove.indexOf(targetProp);index>=0&&remove.splice(index,1)}}const hasIncludeOnChild=includeFilter.some((info=>info.isChildOf(checkPathInfo)));const hasExcludeOnChild=excludeFilter.some((info=>info.isChildOf(checkPathInfo)));if(hasExcludeOnChild&&!hasIncludeOnChild){const excludes=excludeFilter.filter((info=>info.isChildOf(checkPathInfo)));for(let i=0;i<remove.length;i++){if(!excludes.find((info=>info.equals(remove[i])))){remove.splice(i,1);i--}}}for(const key of remove){delete node.value[key]}}};applyFiltersOnInlineData(path,targetNode);let checkExecuted=false;const includeDescendantCheck=(descPath,metadata)=>{checkExecuted=true;if(!transaction.production&&!pathInfo.isAncestorOf(descPath)){this.throwImplementationError(`"${descPath}" is not a descendant of "${path}" - descendantsOf must only check and return paths that are descendants`)}if(!filtered){return true}const descPathKeys=acebase_core_1.PathInfo.getPathKeys(descPath);const trailKeys=descPathKeys.slice(pathInfo.keys.length);const checkPathInfo=new acebase_core_1.PathInfo(trailKeys);let include=(includeFilter.length>0?includeFilter.some((info=>checkPathInfo.isOnTrailOf(info))):true)&&(excludeFilter.length>0?!excludeFilter.some((info=>info.equals(checkPathInfo)||info.isAncestorOf(checkPathInfo))):true);if(include&&options.child_objects===false&&(pathInfo.isParentOf(descPath)&&[node_value_types_1.VALUE_TYPES.OBJECT,node_value_types_1.VALUE_TYPES.ARRAY].includes(metadata?metadata.type:-1)||acebase_core_1.PathInfo.getPathKeys(descPath).length>pathInfo.pathKeys.length+1)){include=false}return include};const descRows=[];const addDescendant=(descPath,node)=>{if(!checkExecuted){this.throwImplementationError("descendantsOf did not call checkCallback before addCallback")}if(options.child_objects===false&&[node_value_types_1.VALUE_TYPES.OBJECT,node_value_types_1.VALUE_TYPES.ARRAY].includes(node.type)){return true}applyFiltersOnInlineData(descPath,node);this._processReadNodeValue(node);const row=node;row.path=descPath;descRows.push(row);return true};await transaction.descendantsOf(path,{metadata:true,value:true},includeDescendantCheck,addDescendant);this.debug.log(`Read node "/${path}" and ${filtered?"(filtered) ":""}descendants from ${descRows.length+1} records`.colorize(acebase_core_1.ColorStyle.magenta));const result=targetNode;const objectToArray=obj=>{const arr=[];Object.keys(obj).forEach((key=>{const index=parseInt(key);arr[index]=obj[index]}));return arr};if(targetNode.type===node_value_types_1.VALUE_TYPES.ARRAY){result.value=objectToArray(result.value)}if(targetNode.type===node_value_types_1.VALUE_TYPES.OBJECT||targetNode.type===node_value_types_1.VALUE_TYPES.ARRAY){const targetPathKeys=acebase_core_1.PathInfo.getPathKeys(path);const value=targetNode.value;for(let i=0;i<descRows.length;i++){const otherNode=descRows[i];const pathKeys=acebase_core_1.PathInfo.getPathKeys(otherNode.path);const trailKeys=pathKeys.slice(targetPathKeys.length);let parent=value;for(let j=0;j<trailKeys.length;j++){(0,assert_1.assert)(typeof parent==="object","parent must be an object/array to have children!!");const key=trailKeys[j];const isLast=j===trailKeys.length-1;const nodeType=isLast?otherNode.type:typeof trailKeys[j+1]==="number"?node_value_types_1.VALUE_TYPES.ARRAY:node_value_types_1.VALUE_TYPES.OBJECT;let nodeValue;if(!isLast){nodeValue=nodeType===node_value_types_1.VALUE_TYPES.OBJECT?{}:[]}else{nodeValue=otherNode.value;if(nodeType===node_value_types_1.VALUE_TYPES.ARRAY){nodeValue=objectToArray(nodeValue)}}if(key in parent){const mergePossible=typeof parent[key]===typeof nodeValue&&[node_value_types_1.VALUE_TYPES.OBJECT,node_value_types_1.VALUE_TYPES.ARRAY].includes(nodeType);if(!mergePossible){this.debug.error(`The value stored in node "${otherNode.path}" cannot be merged with the parent node, value will be ignored. This error should disappear once the target node value is updated. See issue #20 for more information`,{path:path,parent:parent,key:key,nodeType:nodeType,nodeValue:nodeValue})}else{Object.keys(nodeValue).forEach((childKey=>{if(childKey in parent[key]){this.throwImplementationError(`Custom storage merge error: child key "${childKey}" is in parent value already! Make sure the get/childrenOf/descendantsOf methods of the custom storage class return values that can be modified by AceBase without affecting the stored source`)}parent[key][childKey]=nodeValue[childKey]}))}}else{parent[key]=nodeValue}parent=parent[key]}}}else if(descRows.length>0){this.throwImplementationError(`multiple records found for non-object value!`)}if(options.child_objects===false){Object.keys(result.value).forEach((key=>{if(typeof result.value[key]==="object"&&result.value[key].constructor===Object){(0,assert_1.assert)(Object.keys(result.value[key]).length===0);delete result.value[key]}}))}if(options.include){}if(options.exclude){const process=(obj,keys)=>{if(typeof obj!=="object"){return}const key=keys[0];if(key==="*"){Object.keys(obj).forEach((k=>{process(obj[k],keys.slice(1))}))}else if(keys.length>1){key in obj&&process(obj[key],keys.slice(1))}else{delete obj[key]}};options.exclude.forEach((path=>{const checkKeys=acebase_core_1.PathInfo.getPathKeys(path);process(result.value,checkKeys)}))}return result})();if(!options.transaction){await transaction.commit()}return node}catch(err){if(!options.transaction){await transaction.rollback(err)}throw err}}async getNodeInfo(path,options={}){options=options||{};const pathInfo=acebase_core_1.PathInfo.get(path);const transaction=options.transaction||await this._customImplementation.getTransaction({path:path,write:false});try{const node=await this._readNode(path,{transaction:transaction});const info=new CustomStorageNodeInfo({path:path,key:typeof pathInfo.key==="string"?pathInfo.key:null,index:typeof pathInfo.key==="number"?pathInfo.key:null,type:node?node.type:0,exists:node!==null,address:node?new node_address_1.NodeAddress(path):null,created:node?new Date(node.created):null,modified:node?new Date(node.modified):null,revision:node?node.revision:null,revision_nr:node?node.revision_nr:null});if(!node&&path!==""){const lockPath=await transaction.moveToParentPath(pathInfo.parentPath);(0,assert_1.assert)(lockPath===pathInfo.parentPath,`transaction.moveToParentPath() did not move to the right parent path of "${path}"`);const parent=await this._readNode(pathInfo.parentPath,{transaction:transaction});if(parent&&[node_value_types_1.VALUE_TYPES.OBJECT,node_value_types_1.VALUE_TYPES.ARRAY].includes(parent.type)&&pathInfo.key in parent.value){info.exists=true;info.value=parent.value[pathInfo.key];info.address=null;info.type=parent.type;info.created=new Date(parent.created);info.modified=new Date(parent.modified);info.revision=parent.revision;info.revision_nr=parent.revision_nr}else{info.address=null}}if(options.include_child_count){info.childCount=0;if([node_value_types_1.VALUE_TYPES.OBJECT,node_value_types_1.VALUE_TYPES.ARRAY].includes(info.valueType)&&info.address){info.childCount=node.value?Object.keys(node.value).length:0;info.childCount+=await transaction.getChildCount(path)}}if(!options.transaction){await transaction.commit()}return info}catch(err){if(!options.transaction){await transaction.rollback(err)}throw err}}async setNode(path,value,options={suppress_events:false,context:null}){if(this.settings.readOnly){throw new Error(`Database is opened in read-only mode`)}const pathInfo=acebase_core_1.PathInfo.get(path);const transaction=options.transaction||await this._customImplementation.getTransaction({path:path,write:true});try{if(path===""){if(value===null||typeof value!=="object"||value instanceof Array||value instanceof ArrayBuffer||"buffer"in value&&value.buffer instanceof ArrayBuffer){throw new Error(`Invalid value for root node: ${value}`)}await this._writeNodeWithTracking("",value,{merge:false,transaction:transaction,suppress_events:options.suppress_events,context:options.context})}else if(typeof options.assert_revision!=="undefined"){const info=await this.getNodeInfo(path,{transaction:transaction});if(info.revision!==options.assert_revision){throw new node_errors_1.NodeRevisionError(`revision '${info.revision}' does not match requested revision '${options.assert_revision}'`)}if(info.address&&info.address.path===path&&value!==null&&!this.valueFitsInline(value)){await this._writeNodeWithTracking(path,value,{merge:false,transaction:transaction,suppress_events:options.suppress_events,context:options.context})}else{const lockPath=await transaction.moveToParentPath(pathInfo.parentPath);(0,assert_1.assert)(lockPath===pathInfo.parentPath,`transaction.moveToParentPath() did not move to the right parent path of "${path}"`);await this._writeNodeWithTracking(pathInfo.parentPath,{[pathInfo.key]:value},{merge:true,transaction:transaction,suppress_events:options.suppress_events,context:options.context})}}else{const lockPath=await transaction.moveToParentPath(pathInfo.parentPath);(0,assert_1.assert)(lockPath===pathInfo.parentPath,`transaction.moveToParentPath() did not move to the right parent path of "${path}"`);await this.updateNode(pathInfo.parentPath,{[pathInfo.key]:value},{transaction:transaction,suppress_events:options.suppress_events,context:options.context})}if(!options.transaction){await transaction.commit()}}catch(err){if(!options.transaction){await transaction.rollback(err)}throw err}}async updateNode(path,updates,options={suppress_events:false,context:null}){if(this.settings.readOnly){throw new Error(`Database is opened in read-only mode`)}if(typeof updates!=="object"){throw new Error(`invalid updates argument`)}else if(Object.keys(updates).length===0){return}const transaction=options.transaction||await this._customImplementation.getTransaction({path:path,write:true});try{const nodeInfo=await this.getNodeInfo(path,{transaction:transaction});const pathInfo=acebase_core_1.PathInfo.get(path);if(nodeInfo.exists&&nodeInfo.address&&nodeInfo.address.path===path){await this._writeNodeWithTracking(path,updates,{transaction:transaction,merge:true,suppress_events:options.suppress_events,context:options.context})}else if(nodeInfo.exists){const pathInfo=acebase_core_1.PathInfo.get(path);const lockPath=await transaction.moveToParentPath(pathInfo.parentPath);(0,assert_1.assert)(lockPath===pathInfo.parentPath,`transaction.moveToParentPath() did not move to the right parent path of "${path}"`);await this._writeNodeWithTracking(pathInfo.parentPath,{[pathInfo.key]:updates},{transaction:transaction,merge:true,suppress_events:options.suppress_events,context:options.context})}else{const lockPath=await transaction.moveToParentPath(pathInfo.parentPath);(0,assert_1.assert)(lockPath===pathInfo.parentPath,`transaction.moveToParentPath() did not move to the right parent path of "${path}"`);await this.updateNode(pathInfo.parentPath,{[pathInfo.key]:updates},{transaction:transaction,suppress_events:options.suppress_events,context:options.context})}if(!options.transaction){await transaction.commit()}}catch(err){if(!options.transaction){await transaction.rollback(err)}throw err}}}exports.CustomStorage=CustomStorage},{"../../assert":4,"../../node-address":10,"../../node-errors":11,"../../node-info":12,"../../node-lock":13,"../../node-value-types":14,"../index":28,"./helpers":20,"acebase-core":43}],22:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.createIndexedDBInstance=void 0;const acebase_core_1=require("acebase-core");const __1=require("..");const __2=require("../../..");const settings_1=require("./settings");const transaction_1=require("./transaction");function createIndexedDBInstance(dbname,init={}){const settings=new settings_1.IndexedDBStorageSettings(init);const request=indexedDB.open(`${dbname}.acebase`,1);request.onupgradeneeded=e=>{const db=request.result;db.createObjectStore("nodes",{keyPath:"path"});db.createObjectStore("content")};let idb;const readyPromise=new Promise(((resolve,reject)=>{request.onsuccess=e=>{idb=request.result;resolve()};request.onerror=e=>{reject(e)}}));const cache=new acebase_core_1.SimpleCache(typeof settings.cacheSeconds==="number"?settings.cacheSeconds:60);const storageSettings=new __1.CustomStorageSettings({name:"IndexedDB",locking:true,removeVoidProperties:settings.removeVoidProperties,maxInlineValueSize:settings.maxInlineValueSize,lockTimeout:settings.lockTimeout,ready(){return readyPromise},async getTransaction(target){await readyPromise;const context={debug:false,db:idb,cache:cache,ipc:ipc};return new transaction_1.IndexedDBStorageTransaction(context,target)}});const db=new __2.AceBase(dbname,{logLevel:settings.logLevel,storage:storageSettings,sponsor:settings.sponsor});const ipc=db.api.storage.ipc;db.settings.ipcEvents=settings.multipleTabs===true;ipc.on("notification",(async notification=>{const message=notification.data;if(typeof message!=="object"){return}if(message.action==="cache.invalidate"){for(const path of message.paths){cache.remove(path)}}}));return db}exports.createIndexedDBInstance=createIndexedDBInstance},{"..":21,"../../..":6,"./settings":23,"./transaction":24,"acebase-core":43}],23:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.IndexedDBStorageSettings=void 0;const __1=require("../..");class IndexedDBStorageSettings extends __1.StorageSettings{constructor(settings){super(settings);this.multipleTabs=false;this.cacheSeconds=60;this.sponsor=false;if(typeof settings.logLevel==="string"){this.logLevel=settings.logLevel}if(typeof settings.multipleTabs==="boolean"){this.multipleTabs=settings.multipleTabs}if(typeof settings.cacheSeconds==="number"){this.cacheSeconds=settings.cacheSeconds}if(typeof settings.sponsor==="boolean"){this.sponsor=settings.sponsor}["type","ipc","path"].forEach((prop=>{if(prop in settings){console.warn(`${prop} setting is not supported for AceBase IndexedDBStorage`)}}))}}exports.IndexedDBStorageSettings=IndexedDBStorageSettings},{"../..":28}],24:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.IndexedDBStorageTransaction=void 0;const __1=require("..");function _requestToPromise(request){return new Promise(((resolve,reject)=>{request.onsuccess=event=>resolve(request.result||null);request.onerror=reject}))}class IndexedDBStorageTransaction extends __1.CustomStorageTransaction{constructor(context,target){super(target);this.context=context;this.production=true;this._pending=[]}_createTransaction(write=false){const tx=this.context.db.transaction(["nodes","content"],write?"readwrite":"readonly");return tx}_splitMetadata(node){const value=node.value;const copy=Object.assign({},node);delete copy.value;const metadata=copy;return{metadata:metadata,value:value}}async commit(){if(this._pending.length===0){return}const batch=this._pending.splice(0);this.context.ipc.sendNotification({action:"cache.invalidate",paths:batch.map((op=>op.path))});const tx=this._createTransaction(true);try{await new Promise(((resolve,reject)=>{let stop=false,processed=0;const handleError=err=>{stop=true;reject(err)};const handleSuccess=()=>{if(++processed===batch.length){resolve()}};batch.forEach(((op,i)=>{if(stop){return}let r1,r2;const path=op.path;if(op.action==="set"){const{metadata:metadata,value:value}=this._splitMetadata(op.node);const nodeInfo={path:path,metadata:metadata};r1=tx.objectStore("nodes").put(nodeInfo);r2=tx.objectStore("content").put(value,path);this.context.cache.set(path,op.node)}else if(op.action==="remove"){r1=tx.objectStore("content").delete(path);r2=tx.objectStore("nodes").delete(path);this.context.cache.set(path,null)}else{handleError(new Error(`Unknown pending operation "${op.action}" on path "${path}" `))}let succeeded=0;r1.onsuccess=r2.onsuccess=()=>{if(++succeeded===2){handleSuccess()}};r1.onerror=r2.onerror=handleError}))}));tx.commit&&tx.commit()}catch(err){console.error(err);tx.abort&&tx.abort();throw err}}async rollback(err){this._pending=[]}async get(path){if(this.context.cache.has(path)){const cache=this.context.cache.get(path);return cache}const tx=this._createTransaction(false);const r1=_requestToPromise(tx.objectStore("nodes").get(path));const r2=_requestToPromise(tx.objectStore("content").get(path));try{const results=await Promise.all([r1,r2]);tx.commit&&tx.commit();const info=results[0];if(!info){this.context.cache.set(path,null);return null}const node=info.metadata;node.value=results[1];this.context.cache.set(path,node);return node}catch(err){console.error(`IndexedDB get error`,err);tx.abort&&tx.abort();throw err}}set(path,node){this._pending.push({action:"set",path:path,node:node})}remove(path){this._pending.push({action:"remove",path:path})}async removeMultiple(paths){paths.forEach((path=>{this._pending.push({action:"remove",path:path})}))}childrenOf(path,include,checkCallback,addCallback){return this._getChildrenOf(path,Object.assign(Object.assign({},include),{descendants:false}),checkCallback,addCallback)}descendantsOf(path,include,checkCallback,addCallback){return this._getChildrenOf(path,Object.assign(Object.assign({},include),{descendants:true}),checkCallback,addCallback)}_getChildrenOf(path,include,checkCallback,addCallback){return new Promise(((resolve,reject)=>{const pathInfo=__1.CustomStorageHelpers.PathInfo.get(path);const tx=this._createTransaction(false);const store=tx.objectStore("nodes");const query=IDBKeyRange.lowerBound(path,true);const cursor=include.metadata?store.openCursor(query):store.openKeyCursor(query);cursor.onerror=e=>{var _a;(_a=tx.abort)===null||_a===void 0?void 0:_a.call(tx);reject(e)};cursor.onsuccess=async e=>{var _a,_b,_c;const otherPath=(_b=(_a=cursor.result)===null||_a===void 0?void 0:_a.key)!==null&&_b!==void 0?_b:null;let keepGoing=true;if(otherPath===null){keepGoing=false}else if(!pathInfo.isAncestorOf(otherPath)){keepGoing=false}else if(include.descendants||pathInfo.isParentOf(otherPath)){let node;if(include.metadata){const valueCursor=cursor;const data=valueCursor.result.value;node=data.metadata}const shouldAdd=checkCallback(otherPath,node);if(shouldAdd){if(include.value){if(this.context.cache.has(otherPath)){const cache=this.context.cache.get(otherPath);node.value=cache.value}else{const req=tx.objectStore("content").get(otherPath);node.value=await new Promise(((resolve,reject)=>{req.onerror=e=>{resolve(null)};req.onsuccess=e=>{resolve(req.result)}}));this.context.cache.set(otherPath,node.value===null?null:node)}}keepGoing=addCallback(otherPath,node)}}if(keepGoing){try{cursor.result.continue()}catch(err){keepGoing=false}}if(!keepGoing){(_c=tx.commit)===null||_c===void 0?void 0:_c.call(tx);resolve()}}}))}}exports.IndexedDBStorageTransaction=IndexedDBStorageTransaction},{"..":21}],25:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.createLocalStorageInstance=exports.LocalStorageTransaction=exports.LocalStorageSettings=void 0;const __1=require("..");const __2=require("../../..");const settings_1=require("./settings");Object.defineProperty(exports,"LocalStorageSettings",{enumerable:true,get:function(){return settings_1.LocalStorageSettings}});const transaction_1=require("./transaction");Object.defineProperty(exports,"LocalStorageTransaction",{enumerable:true,get:function(){return transaction_1.LocalStorageTransaction}});function createLocalStorageInstance(dbname,init={}){const settings=new settings_1.LocalStorageSettings(init);const ls=settings.provider?settings.provider:settings.temp?localStorage:sessionStorage;const storageSettings=new __1.CustomStorageSettings({name:"LocalStorage",locking:true,removeVoidProperties:settings.removeVoidProperties,maxInlineValueSize:settings.maxInlineValueSize,async ready(){},async getTransaction(target){const context={debug:true,dbname:dbname,localStorage:ls};const transaction=new transaction_1.LocalStorageTransaction(context,target);return transaction}});const db=new __2.AceBase(dbname,{logLevel:settings.logLevel,storage:storageSettings,sponsor:settings.sponsor});db.settings.ipcEvents=settings.multipleTabs===true;return db}exports.createLocalStorageInstance=createLocalStorageInstance},{"..":21,"../../..":6,"./settings":26,"./transaction":27}],26:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.LocalStorageSettings=void 0;const __1=require("../..");class LocalStorageSettings extends __1.StorageSettings{constructor(settings){super(settings);this.temp=false;this.multipleTabs=false;if(typeof settings.temp==="boolean"){this.temp=settings.temp}if(typeof settings.provider==="object"){this.provider=settings.provider}if(typeof settings.multipleTabs==="boolean"){this.multipleTabs=settings.multipleTabs}if(typeof settings.logLevel==="string"){this.logLevel=settings.logLevel}if(typeof settings.sponsor==="boolean"){this.sponsor=settings.sponsor}["type","ipc","path"].forEach((prop=>{if(prop in settings){console.warn(`${prop} setting is not supported for AceBase LocalStorage`)}}))}}exports.LocalStorageSettings=LocalStorageSettings},{"../..":28}],27:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.LocalStorageTransaction=void 0;const __1=require("..");class LocalStorageTransaction extends __1.CustomStorageTransaction{constructor(context,target){super(target);this.context=context;this._storageKeysPrefix=`${this.context.dbname}.acebase::`}async commit(){}async rollback(err){}async get(path){const json=this.context.localStorage.getItem(this.getStorageKeyForPath(path));const val=JSON.parse(json);return val}async set(path,val){const json=JSON.stringify(val);this.context.localStorage.setItem(this.getStorageKeyForPath(path),json)}async remove(path){this.context.localStorage.removeItem(this.getStorageKeyForPath(path))}async childrenOf(path,include,checkCallback,addCallback){const pathInfo=__1.CustomStorageHelpers.PathInfo.get(path);for(let i=0;i<this.context.localStorage.length;i++){const key=this.context.localStorage.key(i);if(!key.startsWith(this._storageKeysPrefix)){continue}const otherPath=this.getPathFromStorageKey(key);if(pathInfo.isParentOf(otherPath)&&checkCallback(otherPath)){let node;if(include.metadata||include.value){const json=this.context.localStorage.getItem(key);node=JSON.parse(json)}const keepGoing=addCallback(otherPath,node);if(!keepGoing){break}}}}async descendantsOf(path,include,checkCallback,addCallback){const pathInfo=__1.CustomStorageHelpers.PathInfo.get(path);for(let i=0;i<this.context.localStorage.length;i++){const key=this.context.localStorage.key(i);if(!key.startsWith(this._storageKeysPrefix)){continue}const otherPath=this.getPathFromStorageKey(key);if(pathInfo.isAncestorOf(otherPath)&&checkCallback(otherPath)){let node;if(include.metadata||include.value){const json=this.context.localStorage.getItem(key);node=JSON.parse(json)}const keepGoing=addCallback(otherPath,node);if(!keepGoing){break}}}}getPathFromStorageKey(key){return key.slice(this._storageKeysPrefix.length)}getStorageKeyForPath(path){return`${this._storageKeysPrefix}${path}`}}exports.LocalStorageTransaction=LocalStorageTransaction},{"..":21}],28:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.Storage=exports.StorageSettings=exports.SchemaValidationError=void 0;const acebase_core_1=require("acebase-core");const node_value_types_1=require("../node-value-types");const node_errors_1=require("../node-errors");const node_info_1=require("../node-info");const ipc_1=require("../ipc");const promise_fs_1=require("../promise-fs");const data_index_1=require("../data-index");const indexes_1=require("./indexes");const assert_1=require("../assert");const{compareValues:compareValues,getChildValues:getChildValues,encodeString:encodeString,defer:defer}=acebase_core_1.Utils;const DEBUG_MODE=false;const SUPPORTED_EVENTS=["value","child_added","child_changed","child_removed","mutated","mutations"];SUPPORTED_EVENTS.push(...SUPPORTED_EVENTS.map((event=>`notify_${event}`)));const NOOP=()=>{};class SchemaValidationError extends Error{constructor(reason){super(`Schema validation failed: ${reason}`);this.reason=reason}}exports.SchemaValidationError=SchemaValidationError;class StorageSettings{constructor(settings={}){this.maxInlineValueSize=50;this.removeVoidProperties=false;this.path=".";this.lockTimeout=120;this.type="data";this.readOnly=false;if(typeof settings.maxInlineValueSize==="number"){this.maxInlineValueSize=settings.maxInlineValueSize}if(typeof settings.removeVoidProperties==="boolean"){this.removeVoidProperties=settings.removeVoidProperties}if(typeof settings.path==="string"){this.path=settings.path}if(this.path.endsWith("/")){this.path=this.path.slice(0,-1)}if(typeof settings.lockTimeout==="number"){this.lockTimeout=settings.lockTimeout}if(typeof settings.type==="string"){this.type=settings.type}if(typeof settings.readOnly==="boolean"){this.readOnly=settings.readOnly}if(["object","string"].includes(typeof settings.ipc)){this.ipc=settings.ipc}}}exports.StorageSettings=StorageSettings;class Storage extends acebase_core_1.SimpleEventEmitter{createTid(){return DEBUG_MODE?++this._lastTid:acebase_core_1.ID.generate()}constructor(name,settings,env){super();this.name=name;this.settings=settings;this._schemas=[];this._indexes=[];this._annoucedIndexes=new Map;this.indexes={get supported(){return promise_fs_1.pfs===null||promise_fs_1.pfs===void 0?void 0:promise_fs_1.pfs.hasFileSystem},create:(path,key,options={rebuild:false})=>{const context={storage:this,debug:this.debug,indexes:this._indexes,ipc:this.ipc};return(0,indexes_1.createIndex)(context,path,key,options)},get:(path,key=null)=>{if(path.includes("$")){const pathKeys=acebase_core_1.PathInfo.getPathKeys(path).map((key=>typeof key==="string"&&key.startsWith("$")?"*":key));path=new acebase_core_1.PathInfo(pathKeys).path}return this._indexes.filter((index=>index.path===path&&(key===null||key===index.key)))},getAll:(targetPath,options={parentPaths:true,childPaths:true})=>{const pathKeys=acebase_core_1.PathInfo.getPathKeys(targetPath);return this._indexes.filter((index=>{const indexKeys=acebase_core_1.PathInfo.getPathKeys(index.path+"/*");if(options.parentPaths&&indexKeys.every(((key,i)=>key==="*"||pathKeys[i]===key))&&[index.key].concat(...index.includeKeys).includes(pathKeys[indexKeys.length])){return true}else if(indexKeys.length<pathKeys.length){return false}else if(!options.childPaths&&indexKeys.length!==pathKeys.length){return false}return pathKeys.every(((key,i)=>[key,"*"].includes(indexKeys[i])))}))},list:()=>this._indexes.slice(),load:async()=>{this._indexes.splice(0);if(!promise_fs_1.pfs.hasFileSystem){return}let files=[];try{files=await promise_fs_1.pfs.readdir(`${this.settings.path}/${this.name}.acebase`)}catch(err){if(err.code!=="ENOENT"){this.debug.error(err)}}const promises=[];files.forEach((fileName=>{if(!fileName.endsWith(".idx")){return}const needsStoragePrefix=this.settings.type!=="data";const hasStoragePrefix=/^\[[a-z]+\]-/.test(fileName);if(!needsStoragePrefix&&!hasStoragePrefix||needsStoragePrefix&&fileName.startsWith(`[${this.settings.type}]-`)){const p=this.indexes.add(fileName);promises.push(p)}}));await Promise.all(promises)},add:async fileName=>{const existingIndex=this._indexes.find((index=>index.fileName===fileName));if(existingIndex){return existingIndex}else if(this._annoucedIndexes.has(fileName)){const index=await this._annoucedIndexes.get(fileName);return index}try{const indexPromise=data_index_1.DataIndex.readFromFile(this,fileName);this._annoucedIndexes.set(fileName,indexPromise);const index=await indexPromise;this._indexes.push(index);this._annoucedIndexes.delete(fileName);return index}catch(err){this.debug.error(err);return null}},delete:async fileName=>{const index=await this.indexes.remove(fileName);await index.delete();this.ipc.sendNotification({type:"index.deleted",fileName:index.fileName,path:index.path,keys:index.key})},remove:async fileName=>{const index=this._indexes.find((index=>index.fileName===fileName));if(!index){throw new Error(`Index ${fileName} not found`)}this._indexes.splice(this._indexes.indexOf(index),1);return index},close:async()=>{const promises=this.indexes.list().map((index=>index.close().catch((err=>this.debug.error(err)))));await Promise.all(promises)}};this._eventSubscriptions={};this.subscriptions={add:(path,type,callback)=>{if(SUPPORTED_EVENTS.indexOf(type)<0){throw new TypeError(`Invalid event type "${type}"`)}let pathSubs=this._eventSubscriptions[path];if(!pathSubs){pathSubs=this._eventSubscriptions[path]=[]}pathSubs.push({created:Date.now(),type:type,callback:callback});this.emit("subscribe",{path:path,event:type,callback:callback})},remove:(path,type,callback)=>{const pathSubs=this._eventSubscriptions[path];if(!pathSubs){return}const next=()=>pathSubs.findIndex((ps=>(type?ps.type===type:true)&&(callback?ps.callback===callback:true)));let i;while((i=next())>=0){pathSubs.splice(i,1)}this.emit("unsubscribe",{path:path,event:type,callback:callback})},hasValueSubscribersForPath(path){const valueNeeded=this.getValueSubscribersForPath(path);return!!valueNeeded},getValueSubscribersForPath:path=>{const pathInfo=new acebase_core_1.PathInfo(path);const valueSubscribers=[];Object.keys(this._eventSubscriptions).forEach((subscriptionPath=>{if(pathInfo.equals(subscriptionPath)||pathInfo.isDescendantOf(subscriptionPath)){const pathSubs=this._eventSubscriptions[subscriptionPath];const eventPath=acebase_core_1.PathInfo.fillVariables(subscriptionPath,path);pathSubs.filter((sub=>!sub.type.startsWith("notify_"))).forEach((sub=>{let dataPath=null;if(sub.type==="value"){dataPath=eventPath}else if(["mutated","mutations"].includes(sub.type)&&pathInfo.isDescendantOf(eventPath)){dataPath=path}else if(sub.type==="child_changed"&&path!==eventPath){const childKey=acebase_core_1.PathInfo.getPathKeys(path.slice(eventPath.length).replace(/^\//,""))[0];dataPath=acebase_core_1.PathInfo.getChildPath(eventPath,childKey)}else if(["child_added","child_removed"].includes(sub.type)&&pathInfo.isChildOf(eventPath)){const childKey=acebase_core_1.PathInfo.getPathKeys(path.slice(eventPath.length).replace(/^\//,""))[0];dataPath=acebase_core_1.PathInfo.getChildPath(eventPath,childKey)}if(dataPath!==null&&!valueSubscribers.some((s=>s.type===sub.type&&s.eventPath===eventPath))){valueSubscribers.push({type:sub.type,eventPath:eventPath,dataPath:dataPath,subscriptionPath:subscriptionPath})}}))}}));return valueSubscribers},getAllSubscribersForPath:path=>{const pathInfo=acebase_core_1.PathInfo.get(path);const subscribers=[];Object.keys(this._eventSubscriptions).forEach((subscriptionPath=>{if(pathInfo.isOnTrailOf(subscriptionPath)){const pathSubs=this._eventSubscriptions[subscriptionPath];const eventPath=acebase_core_1.PathInfo.fillVariables(subscriptionPath,path);pathSubs.forEach((sub=>{let dataPath=null;if(sub.type==="value"||sub.type==="notify_value"){dataPath=eventPath}else if(["child_changed","notify_child_changed"].includes(sub.type)){const childKey=path===eventPath||pathInfo.isAncestorOf(eventPath)?"*":acebase_core_1.PathInfo.getPathKeys(path.slice(eventPath.length).replace(/^\//,""))[0];dataPath=acebase_core_1.PathInfo.getChildPath(eventPath,childKey)}else if(["mutated","mutations","notify_mutated","notify_mutations"].includes(sub.type)){dataPath=path}else if(["child_added","child_removed","notify_child_added","notify_child_removed"].includes(sub.type)&&(pathInfo.isChildOf(eventPath)||path===eventPath||pathInfo.isAncestorOf(eventPath))){const childKey=path===eventPath||pathInfo.isAncestorOf(eventPath)?"*":acebase_core_1.PathInfo.getPathKeys(path.slice(eventPath.length).replace(/^\//,""))[0];dataPath=acebase_core_1.PathInfo.getChildPath(eventPath,childKey)}if(dataPath!==null&&!subscribers.some((s=>s.type===sub.type&&s.eventPath===eventPath&&s.subscriptionPath===subscriptionPath))){subscribers.push({type:sub.type,eventPath:eventPath,dataPath:dataPath,subscriptionPath:subscriptionPath})}}))}}));return subscribers},trigger:(event,path,dataPath,oldValue,newValue,context)=>{const pathSubscriptions=this._eventSubscriptions[path]||[];pathSubscriptions.filter((sub=>sub.type===event)).forEach((sub=>{sub.callback(null,dataPath,newValue,oldValue,context)}))}};this.debug=new acebase_core_1.DebugLogger(env.logLevel,`[${name}${typeof settings.type==="string"&&settings.type!=="data"?`:${settings.type}`:""}]`);const ipcName=name+(typeof settings.type==="string"?`_${settings.type}`:"");if(settings.ipc==="socket"||settings.ipc instanceof ipc_1.NetIPCServer){const ipcSettings={ipcName:ipcName,server:settings.ipc instanceof ipc_1.NetIPCServer?settings.ipc:null};this.ipc=new ipc_1.IPCSocketPeer(this,ipcSettings)}else if(settings.ipc){if(typeof settings.ipc.port!=="number"){throw new Error("IPC port number must be a number")}if(!["master","worker"].includes(settings.ipc.role)){throw new Error(`IPC client role must be either "master" or "worker", not "${settings.ipc.role}"`)}const ipcSettings=Object.assign({dbname:ipcName},settings.ipc);this.ipc=new ipc_1.RemoteIPCPeer(this,ipcSettings)}else{this.ipc=new ipc_1.IPCPeer(this,ipcName)}this.ipc.once("exit",(code=>{if(this.indexes.supported){this.indexes.close()}}));this.nodeLocker={lock:(path,tid,write,comment)=>this.ipc.lock({path:path,tid:tid,write:write,comment:comment})};this._lastTid=0}async close(){await this.ipc.exit()}get path(){return`${this.settings.path}/${this.name}.acebase`}valueFitsInline(value){if(typeof value==="number"||typeof value==="boolean"||value instanceof Date){return true}else if(typeof value==="string"){if(value.length>this.settings.maxInlineValueSize){return false}const encoded=encodeString(value);return encoded.length<this.settings.maxInlineValueSize}else if(value instanceof acebase_core_1.PathReference){if(value.path.length>this.settings.maxInlineValueSize){return false}const encoded=encodeString(value.path);return encoded.length<this.settings.maxInlineValueSize}else if(value instanceof ArrayBuffer){return value.byteLength<this.settings.maxInlineValueSize}else if(value instanceof Array){return value.length===0}else if(typeof value==="object"){return Object.keys(value).length===0}else{throw new TypeError("What else is there?")}}_writeNode(path,value,options){throw new Error("This method must be implemented by subclass")}getUpdateImpact(path,suppressEvents){let topEventPath=path;let hasValueSubscribers=false;const eventSubscriptions=suppressEvents?[]:this.subscriptions.getAllSubscribersForPath(path);const valueSubscribers=suppressEvents?[]:this.subscriptions.getValueSubscribersForPath(path);if(valueSubscribers.length>0){hasValueSubscribers=true;const eventPaths=valueSubscribers.map((sub=>({path:sub.dataPath,keys:acebase_core_1.PathInfo.getPathKeys(sub.dataPath)}))).sort(((a,b)=>{if(a.keys.length<b.keys.length){return-1}else if(a.keys.length>b.keys.length){return 1}return 0}));const first=eventPaths[0];topEventPath=first.path;if(valueSubscribers.filter((sub=>sub.dataPath===topEventPath)).every((sub=>sub.type==="mutated"||sub.type.startsWith("notify_")))){hasValueSubscribers=false}topEventPath=acebase_core_1.PathInfo.fillVariables(topEventPath,path)}const indexes=this.indexes.getAll(path,{childPaths:true,parentPaths:true}).map((index=>({index:index,keys:acebase_core_1.PathInfo.getPathKeys(index.path)}))).sort(((a,b)=>{if(a.keys.length<b.keys.length){return-1}else if(a.keys.length>b.keys.length){return 1}return 0})).map((obj=>obj.index));const keysFilter=[];if(indexes.length>0){indexes.sort(((a,b)=>{if(typeof a._pathKeys==="undefined"){a._pathKeys=acebase_core_1.PathInfo.getPathKeys(a.path)}if(typeof b._pathKeys==="undefined"){b._pathKeys=acebase_core_1.PathInfo.getPathKeys(b.path)}if(a._pathKeys.length<b._pathKeys.length){return-1}else if(a._pathKeys.length>b._pathKeys.length){return 1}return 0}));const topIndex=indexes[0];const topIndexPath=topIndex.path===path?path:acebase_core_1.PathInfo.fillVariables(`${topIndex.path}/*`,path);if(topIndexPath.length<topEventPath.length){topEventPath=topIndexPath;indexes.filter((index=>index.path===topIndex.path)).forEach((index=>{const keys=[index.key].concat(index.includeKeys);keys.forEach((key=>!keysFilter.includes(key)&&keysFilter.push(key)))}))}}return{topEventPath:topEventPath,eventSubscriptions:eventSubscriptions,valueSubscribers:valueSubscribers,hasValueSubscribers:hasValueSubscribers,indexes:indexes,keysFilter:keysFilter}}async _writeNodeWithTracking(path,value,options={merge:false,waitForIndexUpdates:true,suppress_events:false,context:null,impact:null}){options=options||{};if(!options.tid&&!options.transaction){throw new Error("_writeNodeWithTracking MUST be executed with a tid OR transaction!")}options.merge=options.merge===true;const validation=this.validateSchema(path,value,{updates:options.merge});if(!validation.ok){throw new SchemaValidationError(validation.reason)}const tid=options.tid;const transaction=options.transaction;let topEventData=null;const updateImpact=options.impact?options.impact:this.getUpdateImpact(path,options.suppress_events);const{topEventPath:topEventPath,eventSubscriptions:eventSubscriptions,hasValueSubscribers:hasValueSubscribers,indexes:indexes}=updateImpact;let{keysFilter:keysFilter}=updateImpact;const writeNode=()=>{if(typeof options._customWriteFunction==="function"){return options._customWriteFunction()}if(topEventData){const pathKeys=acebase_core_1.PathInfo.getPathKeys(path);const eventPathKeys=acebase_core_1.PathInfo.getPathKeys(topEventPath);const trailKeys=pathKeys.slice(eventPathKeys.length);let currentValue=topEventData;while(trailKeys.length>0&&currentValue!==null){const childKey=trailKeys.shift();currentValue=typeof currentValue==="object"&&childKey in currentValue?currentValue[childKey]:null}options.currentValue=currentValue}return this._writeNode(path,value,options)};const transactionLoggingEnabled=this.settings.transactions&&this.settings.transactions.log===true;if(eventSubscriptions.length===0&&indexes.length===0&&!transactionLoggingEnabled){return writeNode()}if(!hasValueSubscribers&&options.merge===true&&keysFilter.length===0){keysFilter=Object.keys(value);if(topEventPath!==path){const trailPath=path.slice(topEventPath.length);keysFilter=keysFilter.map((key=>`${trailPath}/${key}`))}}const eventNodeInfo=await this.getNodeInfo(topEventPath,{transaction:transaction,tid:tid});let currentValue=null;if(eventNodeInfo.exists){const valueOptions={transaction:transaction,tid:tid};if(keysFilter.length>0){valueOptions.include=keysFilter}if(topEventPath===""&&typeof valueOptions.include==="undefined"){this.debug.warn('WARNING: One or more value event listeners on the root node are causing the entire database value to be read to facilitate change tracking. Using "value", "notify_value", "child_changed" and "notify_child_changed" events on the root node are a bad practice because of the significant performance impact. Use "mutated" or "mutations" events instead')}const node=await this.getNode(topEventPath,valueOptions);currentValue=node.value}topEventData=currentValue;const result=await writeNode()||{};let newTopEventData,modifiedData;if(path===topEventPath){if(options.merge){if(topEventData===null){newTopEventData=value instanceof Array?[]:{}}else{newTopEventData=topEventData instanceof Array?[]:{};Object.keys(topEventData).forEach((key=>{newTopEventData[key]=topEventData[key]}))}}else{newTopEventData=value}modifiedData=newTopEventData}else{const trailPath=path.slice(topEventPath.length).replace(/^\//,"");const trailKeys=acebase_core_1.PathInfo.getPathKeys(trailPath);if(topEventData===null){newTopEventData=typeof trailKeys[0]==="number"?[]:{}}else{newTopEventData=topEventData instanceof Array?[]:{};Object.keys(topEventData).forEach((key=>{newTopEventData[key]=topEventData[key]}))}modifiedData=newTopEventData;while(trailKeys.length>0){const childKey=trailKeys.shift();if(!options.merge&&trailKeys.length===0){modifiedData[childKey]=value}else{const original=modifiedData[childKey];const shallowCopy=typeof childKey==="number"?[...original]:Object.assign({},original);modifiedData[childKey]=shallowCopy}modifiedData=modifiedData[childKey]}}if(options.merge){Object.keys(value).forEach((key=>{modifiedData[key]=value[key]}))}const dataChanges=compareValues(topEventData,newTopEventData);if(dataChanges==="identical"){result.mutations=[];return result}function removeNulls(obj){if(obj===null||typeof obj!=="object"){return obj}Object.keys(obj).forEach((prop=>{const val=obj[prop];if(val===null){delete obj[prop];if(obj instanceof Array){obj.length--}}if(typeof val==="object"){removeNulls(val)}}))}removeNulls(newTopEventData);const indexUpdates=[];indexes.map((index=>({index:index,keys:acebase_core_1.PathInfo.getPathKeys(index.path)}))).sort(((a,b)=>{if(a.keys.length<b.keys.length){return 1}else if(a.keys.length>b.keys.length){return-1}return 0})).forEach((({index:index})=>{const pathKeys=acebase_core_1.PathInfo.getPathKeys(topEventPath);const indexPathKeys=acebase_core_1.PathInfo.getPathKeys(index.path+"/*");const trailKeys=indexPathKeys.slice(pathKeys.length);const oldValue=topEventData;const newValue=newTopEventData;if(trailKeys.length===0){(0,assert_1.assert)(pathKeys.length===indexPathKeys.length,"check logic");const p=this.ipc.isMaster?index.handleRecordUpdate(topEventPath,oldValue,newValue):this.ipc.sendRequest({type:"index.update",fileName:index.fileName,path:topEventPath,oldValue:oldValue,newValue:newValue});indexUpdates.push(p);return}const getAllIndexUpdates=(path,oldValue,newValue)=>{if(oldValue===null&&newValue===null){return[]}const pathKeys=acebase_core_1.PathInfo.getPathKeys(path);const indexPathKeys=acebase_core_1.PathInfo.getPathKeys(index.path+"/*");const trailKeys=indexPathKeys.slice(pathKeys.length);if(trailKeys.length===0){(0,assert_1.assert)(pathKeys.length===indexPathKeys.length,"check logic");return[{path:path,oldValue:oldValue,newValue:newValue}]}let results=[];let trailPath="";while(trailKeys.length>0){const subKey=trailKeys.shift();if(typeof subKey==="string"&&(subKey==="*"||subKey.startsWith("$"))){const allKeys=oldValue===null?[]:Object.keys(oldValue);newValue!==null&&Object.keys(newValue).forEach((key=>{if(allKeys.indexOf(key)<0){allKeys.push(key)}}));allKeys.forEach((key=>{const childPath=acebase_core_1.PathInfo.getChildPath(trailPath,key);const childValues=getChildValues(key,oldValue,newValue);const subTrailPath=acebase_core_1.PathInfo.getChildPath(path,childPath);const childResults=getAllIndexUpdates(subTrailPath,childValues.oldValue,childValues.newValue);results=results.concat(childResults)}));break}else{const values=getChildValues(subKey,oldValue,newValue);oldValue=values.oldValue;newValue=values.newValue;if(oldValue===null&&newValue===null){break}trailPath=acebase_core_1.PathInfo.getChildPath(trailPath,subKey)}}return results};const results=getAllIndexUpdates(topEventPath,oldValue,newValue);results.forEach((result=>{const p=this.ipc.isMaster?index.handleRecordUpdate(result.path,result.oldValue,result.newValue):this.ipc.sendRequest({type:"index.update",fileName:index.fileName,path:result.path,oldValue:result.oldValue,newValue:result.newValue});indexUpdates.push(p)}))}));const callSubscriberWithValues=(sub,oldValue,newValue,variables=[])=>{let trigger=true;let type=sub.type;if(type.startsWith("notify_")){type=type.slice("notify_".length)}if(type==="mutated"){return}else if(type==="child_changed"&&(oldValue===null||newValue===null)){trigger=false}else if(type==="value"||type==="child_changed"){const changes=compareValues(oldValue,newValue);trigger=changes!=="identical"}else if(type==="child_added"){trigger=oldValue===null&&newValue!==null}else if(type==="child_removed"){trigger=oldValue!==null&&newValue===null}if(!trigger){return}const pathKeys=acebase_core_1.PathInfo.getPathKeys(sub.dataPath);variables.forEach((variable=>{const index=pathKeys.indexOf(variable.name);(0,assert_1.assert)(index>=0,`Variable "${variable.name}" not found in subscription dataPath "${sub.dataPath}"`);pathKeys[index]=variable.value}));const dataPath=pathKeys.reduce(((path,key)=>acebase_core_1.PathInfo.getChildPath(path,key)),"");this.subscriptions.trigger(sub.type,sub.subscriptionPath,dataPath,oldValue,newValue,options.context)};const prepareMutationEvents=(currentPath,oldValue,newValue,compareResult)=>{const batch=[];const result=compareResult||compareValues(oldValue,newValue);if(result==="identical"){return batch}else if(typeof result==="string"){batch.push({path:currentPath,oldValue:oldValue,newValue:newValue})}else{result.changed.forEach((info=>{const childPath=acebase_core_1.PathInfo.getChildPath(currentPath,info.key);const childValues=getChildValues(info.key,oldValue,newValue);const childBatch=prepareMutationEvents(childPath,childValues.oldValue,childValues.newValue,info.change);batch.push(...childBatch)}));result.added.forEach((key=>{const childPath=acebase_core_1.PathInfo.getChildPath(currentPath,key);batch.push({path:childPath,oldValue:null,newValue:newValue[key]})}));if(oldValue instanceof Array&&newValue instanceof Array){result.removed.sort(((a,b)=>a<b?1:-1))}result.removed.forEach((key=>{const childPath=acebase_core_1.PathInfo.getChildPath(currentPath,key);batch.push({path:childPath,oldValue:oldValue[key],newValue:null})}))}return batch};if(transactionLoggingEnabled&&this.settings.type!=="transaction"){result.mutations=(()=>{const trailPath=path.slice(topEventPath.length).replace(/^\//,"");const trailKeys=acebase_core_1.PathInfo.getPathKeys(trailPath);let oldValue=topEventData,newValue=newTopEventData;while(trailKeys.length>0){const key=trailKeys.shift();({oldValue:oldValue,newValue:newValue}=getChildValues(key,oldValue,newValue))}const compareResults=compareValues(oldValue,newValue);const batch=prepareMutationEvents(path,oldValue,newValue,compareResults);const mutations=batch.map((m=>({target:acebase_core_1.PathInfo.getPathKeys(m.path.slice(path.length)),prev:m.oldValue,val:m.newValue})));return mutations})()}const triggerAllEvents=()=>{eventSubscriptions.filter((sub=>!["mutated","mutations","notify_mutated","notify_mutations"].includes(sub.type))).map((sub=>{const keys=acebase_core_1.PathInfo.getPathKeys(sub.dataPath);return{sub:sub,keys:keys}})).sort(((a,b)=>{if(a.keys.length<b.keys.length){return 1}else if(a.keys.length>b.keys.length){return-1}return 0})).forEach((({sub:sub})=>{const process=(currentPath,oldValue,newValue,variables=[])=>{const trailPath=sub.dataPath.slice(currentPath.length).replace(/^\//,"");const trailKeys=acebase_core_1.PathInfo.getPathKeys(trailPath);while(trailKeys.length>0){const subKey=trailKeys.shift();if(typeof subKey==="string"&&(subKey==="*"||subKey[0]==="$")){const allKeys=oldValue===null?[]:Object.keys(oldValue).map((key=>oldValue instanceof Array?parseInt(key):key));newValue!==null&&Object.keys(newValue).forEach((key=>{const keyOrIndex=newValue instanceof Array?parseInt(key):key;!allKeys.includes(keyOrIndex)&&allKeys.push(key)}));allKeys.forEach((key=>{const childValues=getChildValues(key,oldValue,newValue);const vars=variables.concat({name:subKey,value:key});if(trailKeys.length===0){callSubscriberWithValues(sub,childValues.oldValue,childValues.newValue,vars)}else{process(acebase_core_1.PathInfo.getChildPath(currentPath,subKey),childValues.oldValue,childValues.newValue,vars)}}));return}else{currentPath=acebase_core_1.PathInfo.getChildPath(currentPath,subKey);const childValues=getChildValues(subKey,oldValue,newValue);oldValue=childValues.oldValue;newValue=childValues.newValue}}callSubscriberWithValues(sub,oldValue,newValue,variables)};if(sub.type.startsWith("notify_")&&acebase_core_1.PathInfo.get(sub.eventPath).isAncestorOf(topEventPath)){const isOnParentPath=acebase_core_1.PathInfo.get(sub.eventPath).isParentOf(topEventPath);const trigger=sub.type==="notify_value"||sub.type==="notify_child_changed"&&(!isOnParentPath||!["added","removed"].includes(dataChanges))||sub.type==="notify_child_removed"&&dataChanges==="removed"&&isOnParentPath||sub.type==="notify_child_added"&&dataChanges==="added"&&isOnParentPath;trigger&&this.subscriptions.trigger(sub.type,sub.subscriptionPath,sub.dataPath,null,null,options.context)}else{process(topEventPath,topEventData,newTopEventData)}}));const mutationEvents=eventSubscriptions.filter((sub=>["mutated","mutations","notify_mutated","notify_mutations"].includes(sub.type)));mutationEvents.forEach((sub=>{let currentPath=topEventPath;const trailKeys=acebase_core_1.PathInfo.getPathKeys(sub.eventPath).slice(acebase_core_1.PathInfo.getPathKeys(currentPath).length);const events=[];let oldValue=topEventData,newValue=newTopEventData;const processNextTrailKey=(target,currentTarget,oldValue,newValue,vars)=>{if(target.length===0){return events.push({target:currentTarget,oldValue:oldValue,newValue:newValue,vars:vars})}const subKey=target[0];const keys=new Set;const isWildcardKey=typeof subKey==="string"&&(subKey==="*"||subKey.startsWith("$"));if(isWildcardKey){if(oldValue!==null&&typeof oldValue==="object"){Object.keys(oldValue).forEach((key=>keys.add(key)))}if(newValue!==null&&typeof newValue==="object"){Object.keys(newValue).forEach((key=>keys.add(key)))}}else{keys.add(subKey)}for(const key of keys){const childValues=getChildValues(key,oldValue,newValue);oldValue=childValues.oldValue;newValue=childValues.newValue;processNextTrailKey(target.slice(1),currentTarget.concat(key),oldValue,newValue,isWildcardKey?vars.concat({name:subKey,value:key}):vars)}};processNextTrailKey(trailKeys,[],oldValue,newValue,[]);for(const event of events){const targetPath=acebase_core_1.PathInfo.get(currentPath).child(event.target).path;const batch=prepareMutationEvents(targetPath,event.oldValue,event.newValue);if(batch.length===0){continue}const isNotifyEvent=sub.type.startsWith("notify_");if(["mutated","notify_mutated"].includes(sub.type)){batch.forEach(((mutation,index)=>{const context=options.context;const prevVal=isNotifyEvent?null:mutation.oldValue;const newVal=isNotifyEvent?null:mutation.newValue;this.subscriptions.trigger(sub.type,sub.subscriptionPath,mutation.path,prevVal,newVal,context)}))}else if(["mutations","notify_mutations"].includes(sub.type)){const subscriptionPathKeys=acebase_core_1.PathInfo.getPathKeys(sub.subscriptionPath);const values=isNotifyEvent?null:batch.map((m=>({target:acebase_core_1.PathInfo.getPathKeys(m.path).slice(subscriptionPathKeys.length),prev:m.oldValue,val:m.newValue})));const dataPath=acebase_core_1.PathInfo.get(acebase_core_1.PathInfo.getPathKeys(targetPath).slice(0,subscriptionPathKeys.length)).path;this.subscriptions.trigger(sub.type,sub.subscriptionPath,dataPath,null,values,options.context)}}}))};if(options.waitForIndexUpdates===false){indexUpdates.splice(0)}await Promise.all(indexUpdates);defer(triggerAllEvents);return result}getChildren(path,options){throw new Error("This method must be implemented by subclass")}async getNodeValue(path,options={}){const node=await this.getNode(path,options);return node.value}getNode(path,options){throw new Error("This method must be implemented by subclass")}getNodeInfo(path,options){throw new Error("This method must be implemented by subclass")}setNode(path,value,options){throw new Error("This method must be implemented by subclass")}updateNode(path,updates,options){throw new Error("This method must be implemented by subclass")}async transactNode(path,callback,options={no_lock:false,suppress_events:false,context:null}){const useFakeLock=options&&options.no_lock===true;const tid=this.createTid();const lock=useFakeLock?{tid:tid,release:NOOP}:await this.nodeLocker.lock(path,tid,true,"transactNode");try{let changed=false;const changeCallback=()=>{changed=true};if(useFakeLock){this.subscriptions.add(path,"notify_value",changeCallback)}const node=await this.getNode(path,{tid:tid});const checkRevision=node.revision;let newValue;try{newValue=callback(node.value);if(newValue instanceof Promise){newValue=await newValue.catch((err=>{this.debug.error(`Error in transaction callback: ${err.message}`)}))}}catch(err){this.debug.error(`Error in transaction callback: ${err.message}`)}if(typeof newValue==="undefined"){return}if(useFakeLock){this.subscriptions.remove(path,"notify_value",changeCallback)}if(changed){throw new node_errors_1.NodeRevisionError("Node changed")}const cursor=await this.setNode(path,newValue,{assert_revision:checkRevision,tid:lock.tid,suppress_events:options.suppress_events,context:options.context});return cursor}catch(err){if(err instanceof node_errors_1.NodeRevisionError){console.warn(`node value changed, running again. Error: ${err.message}`);return this.transactNode(path,callback,options)}else{throw err}}finally{lock.release()}}async matchNode(path,criteria,options){var _a;const tid=(_a=options===null||options===void 0?void 0:options.tid)!==null&&_a!==void 0?_a:acebase_core_1.ID.generate();const checkNode=async(path,criteria)=>{if(criteria.length===0){return Promise.resolve(true)}const criteriaKeys=criteria.reduce(((keys,cr)=>{let key=cr.key;if(typeof key==="string"&&key.includes("/")){key=key.slice(0,key.indexOf("/"))}if(keys.indexOf(key)<0){keys.push(key)}return keys}),[]);const unseenKeys=criteriaKeys.slice();let isMatch=true;const delayedMatchPromises=[];try{await this.getChildren(path,{tid:tid,keyFilter:criteriaKeys}).next((childInfo=>{var _a;const keyOrIndex=(_a=childInfo.key)!==null&&_a!==void 0?_a:childInfo.index;unseenKeys.includes(keyOrIndex)&&unseenKeys.splice(unseenKeys.indexOf(childInfo.key),1);const keyCriteria=criteria.filter((cr=>cr.key===keyOrIndex)).map((cr=>({op:cr.op,compare:cr.compare})));const keyResult=keyCriteria.length>0?checkChild(childInfo,keyCriteria):{isMatch:true,promises:[]};isMatch=keyResult.isMatch;if(isMatch){delayedMatchPromises.push(...keyResult.promises);const childCriteria=criteria.filter((cr=>typeof cr.key==="string"&&cr.key.startsWith(`${typeof keyOrIndex==="number"?`[${keyOrIndex}]`:keyOrIndex}/`))).map((cr=>{const key=cr.key.slice(cr.key.indexOf("/")+1);return{key:key,op:cr.op,compare:cr.compare}}));if(childCriteria.length>0){const childPath=acebase_core_1.PathInfo.getChildPath(path,childInfo.key);const childPromise=checkNode(childPath,childCriteria).then((isMatch=>({isMatch:isMatch})));delayedMatchPromises.push(childPromise)}}if(!isMatch||unseenKeys.length===0){return false}}));if(isMatch){const results=await Promise.all(delayedMatchPromises);isMatch=results.every((res=>res.isMatch))}if(!isMatch){return false}isMatch=unseenKeys.every((keyOrIndex=>{const childInfo=new node_info_1.NodeInfo(Object.assign(Object.assign(Object.assign({},typeof keyOrIndex==="number"&&{index:keyOrIndex}),typeof keyOrIndex==="string"&&{key:keyOrIndex}),{exists:false}));const childCriteria=criteria.filter((cr=>typeof cr.key==="string"&&cr.key.startsWith(`${typeof keyOrIndex==="number"?`[${keyOrIndex}]`:keyOrIndex}/`))).map((cr=>({op:cr.op,compare:cr.compare})));if(childCriteria.length>0&&!checkChild(childInfo,childCriteria).isMatch){return false}const keyCriteria=criteria.filter((cr=>cr.key===keyOrIndex)).map((cr=>({op:cr.op,compare:cr.compare})));if(keyCriteria.length===0){return true}const result=checkChild(childInfo,keyCriteria);return result.isMatch}));return isMatch}catch(err){this.debug.error(`Error matching on "${path}": `,err);throw err}};const checkChild=(child,criteria)=>{const promises=[];const isMatch=criteria.every((f=>{let proceed=true;if(f.op==="!exists"||f.op==="=="&&(typeof f.compare==="undefined"||f.compare===null)){proceed=!child.exists}else if(f.op==="exists"||f.op==="!="&&(typeof f.compare==="undefined"||f.compare===null)){proceed=child.exists}else if((f.op==="contains"||f.op==="!contains")&&f.compare instanceof Array&&f.compare.length===0){proceed=true}else if(!child.exists){proceed=false}else{if(child.address){if(child.valueType===node_value_types_1.VALUE_TYPES.OBJECT&&["has","!has"].indexOf(f.op)>=0){const op=f.op==="has"?"exists":"!exists";const p=checkNode(child.path,[{key:f.compare,op:op}]).then((isMatch=>({key:child.key,isMatch:isMatch})));promises.push(p);proceed=true}else if(child.valueType===node_value_types_1.VALUE_TYPES.ARRAY&&["contains","!contains"].indexOf(f.op)>=0){const p=this.getNode(child.path,{tid:tid}).then((({value:arr})=>{const isMatch=f.op==="contains"?f.compare instanceof Array?f.compare.every((val=>arr.includes(val))):arr.includes(f.compare):f.compare instanceof Array?!f.compare.some((val=>arr.includes(val))):!arr.includes(f.compare);return{key:child.key,isMatch:isMatch}}));promises.push(p);proceed=true}else if(child.valueType===node_value_types_1.VALUE_TYPES.STRING){const p=this.getNode(child.path,{tid:tid}).then((node=>({key:child.key,isMatch:this.test(node.value,f.op,f.compare)})));promises.push(p);proceed=true}else{proceed=false}}else if(child.type===node_value_types_1.VALUE_TYPES.OBJECT&&["has","!has"].indexOf(f.op)>=0){const has=f.compare in child.value;proceed=has&&f.op==="has"||!has&&f.op==="!has"}else if(child.type===node_value_types_1.VALUE_TYPES.ARRAY&&["contains","!contains"].indexOf(f.op)>=0){const contains=child.value.indexOf(f.compare)>=0;proceed=contains&&f.op==="contains"||!contains&&f.op==="!contains"}else{let ret=this.test(child.value,f.op,f.compare);if(ret instanceof Promise){promises.push(ret);ret=true}proceed=ret}}return proceed}));return{isMatch:isMatch,promises:promises}};return checkNode(path,criteria)}test(val,op,compare){if(op==="<"){return val<compare}if(op==="<="){return val<=compare}if(op==="=="){return val===compare}if(op==="!="){return val!==compare}if(op===">"){return val>compare}if(op===">="){return val>=compare}if(op==="in"){return compare.indexOf(val)>=0}if(op==="!in"){return compare.indexOf(val)<0}if(op==="like"||op==="!like"){const pattern="^"+compare.replace(/[-[\]{}()+.,\\^$|#\s]/g,"\\$&").replace(/\?/g,".").replace(/\*/g,".*?")+"$";const re=new RegExp(pattern,"i");const isMatch=re.test(val.toString());return op==="like"?isMatch:!isMatch}if(op==="matches"){return compare.test(val.toString())}if(op==="!matches"){return!compare.test(val.toString())}if(op==="between"){return val>=compare[0]&&val<=compare[1]}if(op==="!between"){return val<compare[0]||val>compare[1]}if(op==="has"||op==="!has"){const has=typeof val==="object"&&compare in val;return op==="has"?has:!has}if(op==="contains"||op==="!contains"){const includes=typeof val==="object"&&val instanceof Array&&val.includes(compare);return op==="contains"?includes:!includes}return false}async exportNode(path,writeFn,options={format:"json",type_safe:true}){if((options===null||options===void 0?void 0:options.format)!=="json"){throw new Error("Only json output is currently supported")}const write=typeof writeFn!=="function"?writeFn.write.bind(writeFn):writeFn;const stringifyValue=(type,val)=>{const escape=str=>str.replace(/\\/g,"\\\\").replace(/"/g,'\\"').replace(/\r/g,"\\r").replace(/\n/g,"\\n").replace(/\t/g,"\\t").replace(/[\u0000-\u001f]/g,(ch=>`\\u${ch.charCodeAt(0).toString(16).padStart(4,"0")}`));if(type===node_value_types_1.VALUE_TYPES.DATETIME){val=`"${val.toISOString()}"`;if(options.type_safe){val=`{".type":"date",".val":${val}}`}}else if(type===node_value_types_1.VALUE_TYPES.STRING){val=`"${escape(val)}"`}else if(type===node_value_types_1.VALUE_TYPES.ARRAY){val="[]"}else if(type===node_value_types_1.VALUE_TYPES.OBJECT){val="{}"}else if(type===node_value_types_1.VALUE_TYPES.BINARY){val=`"${escape(acebase_core_1.ascii85.encode(val))}"`;if(options.type_safe){val=`{".type":"binary",".val":${val}}`}}else if(type===node_value_types_1.VALUE_TYPES.REFERENCE){val=`"${val.path}"`;if(options.type_safe){val=`{".type":"reference",".val":${val}}`}}else if(type===node_value_types_1.VALUE_TYPES.BIGINT){val=`"${val}"`;if(options.type_safe){val=`{".type":"bigint",".val":${val}}`}}return val};let objStart="",objEnd="";const nodeInfo=await this.getNodeInfo(path);if(!nodeInfo.exists){return write("null")}else if(nodeInfo.type===node_value_types_1.VALUE_TYPES.OBJECT){objStart="{";objEnd="}"}else if(nodeInfo.type===node_value_types_1.VALUE_TYPES.ARRAY){objStart="[";objEnd="]"}else{const node=await this.getNode(path);const val=stringifyValue(nodeInfo.type,node.value);return write(val)}if(objStart){const p=write(objStart);if(p instanceof Promise){await p}}let output="",outputCount=0;const pending=[];await this.getChildren(path).next((childInfo=>{if(childInfo.address){pending.push(childInfo)}else{if(outputCount++>0){output+=","}if(typeof childInfo.key==="string"){output+=`"${childInfo.key}":`}output+=stringifyValue(childInfo.type,childInfo.value)}}));if(output){const p=write(output);if(p instanceof Promise){await p}}while(pending.length>0){const childInfo=pending.shift();let output=outputCount++>0?",":"";const key=typeof childInfo.index==="number"?childInfo.index:childInfo.key;if(typeof key==="string"){output+=`"${key}":`}if(output){const p=write(output);if(p instanceof Promise){await p}}await this.exportNode(acebase_core_1.PathInfo.getChildPath(path,key),write,options)}if(objEnd){const p=write(objEnd);if(p instanceof Promise){await p}}}async importNode(path,read,options={format:"json",method:"set"}){const chunkSize=256*1024;const maxQueueBytes=1024*1024;const state={data:"",index:0,offset:0,queue:[],queueStartByte:0,timesFlushed:0,get processedBytes(){return this.offset+this.index}};const readNextChunk=async(append=false)=>{let data=await read(chunkSize);if(data===null){if(state.data){throw new Error(`Unexpected EOF at index ${state.offset+state.data.length}`)}else{throw new Error("Unable to read data from stream")}}else if(typeof data==="object"){data=acebase_core_1.Utils.decodeString(data)}if(append){state.data+=data}else{state.offset+=state.data.length;state.data=data;state.index=0}};const readBytes=async length=>{let str="";if(state.index+length>=state.data.length){str=state.data.slice(state.index);length-=str.length;await readNextChunk()}str+=state.data.slice(state.index,state.index+length);state.index+=length;return str};const assertBytes=async length=>{if(state.index+length>state.data.length){await readNextChunk(true)}if(state.index+length>state.data.length){throw new Error("Not enough data available from stream")}};const consumeToken=async token=>{const str=await readBytes(token.length);if(str!==token){throw new Error(`Unexpected character "${str[0]}" at index ${state.offset+state.index}, expected "${token}"`)}};const consumeSpaces=async()=>{const spaces=[" ","\t","\r","\n"];while(true){if(state.index>=state.data.length){await readNextChunk()}if(spaces.includes(state.data[state.index])){state.index++}else{break}}};const peekBytes=async length=>{await assertBytes(length);const index=state.index;return state.data.slice(index,index+length)};const peekValueType=async()=>{await consumeSpaces();const ch=await peekBytes(1);switch(ch){case'"':return"string";case"{":return"object";case"[":return"array";case"n":return"null";case"u":return"undefined";case"t":case"f":return"boolean";default:{if(ch==="-"||ch>="0"&&ch<="9"){return"number"}throw new Error(`Unknown value at index ${state.offset+state.index}`)}}};const readString=async()=>{await consumeToken('"');let str="";let i=state.index;while(state.data[i]!=='"'||state.data[i-1]==="\\"){i++;if(i>=state.data.length){str+=state.data.slice(state.index);await readNextChunk();i=0}}str+=state.data.slice(state.index,i);state.index=i+1;return unescape(str)};const readBoolean=async()=>{if(state.data[state.index]==="t"){await consumeToken("true")}else if(state.data[state.index]==="f"){await consumeToken("false")}throw new Error(`Expected true or false at index ${state.offset+state.index}`)};const readNumber=async()=>{let str="";let i=state.index;const nrChars=["-","0","1","2","3","4","5","6","7","8","9",".","e","b","f","x","o","n"];while(nrChars.includes(state.data[i])){i++;if(i>=state.data.length){str+=state.data.slice(state.index);await readNextChunk();i=0}}str+=state.data.slice(state.index,i);state.index=i;const nr=str.endsWith("n")?BigInt(str.slice(0,-1)):str.includes(".")?parseFloat(str):parseInt(str);return nr};const readValue=async()=>{await consumeSpaces();const type=await peekValueType();const value=await(()=>{switch(type){case"string":return readString();case"object":return{};case"array":return[];case"number":return readNumber();case"null":return null;case"undefined":return undefined;case"boolean":return readBoolean()}})();return{type:type,value:value}};const unescape=str=>str.replace(/\\n/g,"\n").replace(/\\"/g,'"');const getTypeSafeValue=(path,obj)=>{const type=obj[".type"];let val=obj[".val"];switch(type){case"Date":case"date":{val=new Date(val);break}case"Buffer":case"binary":{val=unescape(val);if(val.startsWith("<~")){val=acebase_core_1.ascii85.decode(val)}else{throw new Error(`Import error: Unexpected encoding for value for value at path "/${path}"`)}break}case"PathReference":case"reference":{val=new acebase_core_1.PathReference(val);break}case"bigint":{val=BigInt(val);break}default:throw new Error(`Import error: Unsupported type "${type}" for value at path "/${path}"`)}return val};const context={acebase_import_id:acebase_core_1.ID.generate()};const childOptions={suppress_events:options.suppress_events,context:context};const enqueue=async(target,value)=>{state.queue.push({target:target,value:value});if(state.processedBytes>=state.queueStartByte+maxQueueBytes){const operations=state.queue.reduce(((updates,item)=>{if(item.target.path===path){updates.push(Object.assign({op:options.method==="set"&&state.timesFlushed===0?"set":"update"},item))}else{const parent=updates.find((other=>other.target.isParentOf(item.target)));if(parent){parent.value[item.target.key]=item.value}else{updates.push(Object.assign({op:options.method==="merge"?"update":"set"},item))}}return updates}),[]);state.queueStartByte=state.processedBytes;state.queue=[];state.timesFlushed++}if(target.path===path){}};const importObject=async target=>{await consumeToken("{");await consumeSpaces();const nextChar=await peekBytes(1);if(nextChar==="}"){state.index++;return this.setNode(target.path,{},childOptions)}let childCount=0;let obj={};let flushedBefore=false;const flushObject=async()=>{let p;if(!flushedBefore){flushedBefore=true;p=this.setNode(target.path,obj,childOptions)}else if(Object.keys(obj).length>0){p=this.updateNode(target.path,obj,childOptions)}obj={};if(p){await p}};const promises=[];while(true){await consumeSpaces();const property=await readString();await consumeSpaces();await consumeToken(":");await consumeSpaces();const{value:value,type:type}=await readValue();obj[property]=value;childCount++;if(["object","array"].includes(type)){promises.push(flushObject());if(type==="object"){await importObject(target.child(property))}else{await importArray(target.child(property))}}await consumeSpaces();const nextChar=await peekBytes(1);if(nextChar==="}"){state.index++;break}await consumeToken(",")}const isTypedValue=childCount===2&&".type"in obj&&".val"in obj;if(isTypedValue){const val=getTypeSafeValue(target.path,obj);return this.setNode(target.path,val,childOptions)}promises.push(flushObject());await Promise.all(promises)};const importArray=async target=>{await consumeToken("[");await consumeSpaces();const nextChar=await peekBytes(1);if(nextChar==="]"){state.index++;return this.setNode(target.path,[],childOptions)}let flushedBefore=false;let arr=[];let updates={};const flushArray=async()=>{let p;if(!flushedBefore){flushedBefore=true;p=this.setNode(target.path,arr,childOptions);arr=null}else if(Object.keys(updates).length>0){p=this.updateNode(target.path,updates,childOptions);updates={}}if(p){await p}};const pushChild=(value,index)=>{if(flushedBefore){updates[index]=value}else{arr.push(value)}};const promises=[];let index=0;while(true){await consumeSpaces();const{value:value,type:type}=await readValue();pushChild(value,index);if(["object","array"].includes(type)){promises.push(flushArray());if(type==="object"){await importObject(target.child(index))}else{await importArray(target.child(index))}}await consumeSpaces();const nextChar=await peekBytes(1);if(nextChar==="]"){state.index++;break}await consumeToken(",");index++}promises.push(flushArray());await Promise.all(promises)};const start=async()=>{const{value:value,type:type}=await readValue();if(["object","array"].includes(type)){const target=acebase_core_1.PathInfo.get(path);if(type==="object"){await importObject(target)}else{await importArray(target)}}else{await this.setNode(path,value,childOptions)}};return start()}setSchema(path,schema,warnOnly=false){if(typeof schema==="undefined"){throw new TypeError("schema argument must be given")}if(schema===null){const i=this._schemas.findIndex((s=>s.path===path));i>=0&&this._schemas.splice(i,1);return}const definition=new acebase_core_1.SchemaDefinition(schema,{warnOnly:warnOnly,warnCallback:message=>this.debug.warn(message)});const item=this._schemas.find((s=>s.path===path));if(item){item.schema=definition}else{this._schemas.push({path:path,schema:definition});this._schemas.sort(((a,b)=>{const ka=acebase_core_1.PathInfo.getPathKeys(a.path),kb=acebase_core_1.PathInfo.getPathKeys(b.path);if(ka.length===kb.length){return 0}return ka.length<kb.length?-1:1}))}}getSchema(path){const item=this._schemas.find((item=>item.path===path));return item?{path:path,schema:item.schema.source,text:item.schema.text}:null}getSchemas(){return this._schemas.map((item=>({path:item.path,schema:item.schema.source,text:item.schema.text})))}validateSchema(path,value,options={updates:false}){let result={ok:true};const pathInfo=acebase_core_1.PathInfo.get(path);this._schemas.filter((s=>pathInfo.isOnTrailOf(s.path))).every((s=>{if(pathInfo.isDescendantOf(s.path)){const ancestorPath=acebase_core_1.PathInfo.fillVariables(s.path,path);const trailKeys=pathInfo.keys.slice(acebase_core_1.PathInfo.getPathKeys(s.path).length);result=s.schema.check(ancestorPath,value,options.updates,trailKeys);return result.ok}const trailKeys=acebase_core_1.PathInfo.getPathKeys(s.path).slice(pathInfo.keys.length);if(options.updates===true&&trailKeys.length>0&&!(trailKeys[0]in value)){return result.ok}const partial=options.updates===true&&trailKeys.length===0;const check=(path,value,trailKeys)=>{if(trailKeys.length===0){return s.schema.check(path,value,partial)}else if(value===null){return{ok:true}}const key=trailKeys[0];if(typeof key==="string"&&(key==="*"||key[0]==="$")){if(value===null||typeof value!=="object"){return{ok:true}}let result;Object.keys(value).every((childKey=>{const childPath=acebase_core_1.PathInfo.getChildPath(path,childKey);const childValue=value[childKey];result=check(childPath,childValue,trailKeys.slice(1));return result.ok}));return result}else{const childPath=acebase_core_1.PathInfo.getChildPath(path,key);const childValue=value[key];return check(childPath,childValue,trailKeys.slice(1))}};result=check(path,value,trailKeys);return result.ok}));return result}}exports.Storage=Storage},{"../assert":4,"../data-index":7,"../ipc":8,"../node-errors":11,"../node-info":12,"../node-value-types":14,"../promise-fs":16,"./indexes":29,"acebase-core":43}],29:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.createIndex=void 0;var create_index_1=require("./create-index");Object.defineProperty(exports,"createIndex",{enumerable:true,get:function(){return create_index_1.createIndex}})},{"./create-index":19}],30:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.MSSQLStorage=exports.MSSQLStorageSettings=void 0;const not_supported_1=require("../../not-supported");class MSSQLStorageSettings extends not_supported_1.NotSupported{}exports.MSSQLStorageSettings=MSSQLStorageSettings;class MSSQLStorage extends not_supported_1.NotSupported{}exports.MSSQLStorage=MSSQLStorage},{"../../not-supported":15}],31:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.SQLiteStorage=exports.SQLiteStorageSettings=void 0;const not_supported_1=require("../../not-supported");class SQLiteStorageSettings extends not_supported_1.NotSupported{}exports.SQLiteStorageSettings=SQLiteStorageSettings;class SQLiteStorage extends not_supported_1.NotSupported{}exports.SQLiteStorage=SQLiteStorage},{"../../not-supported":15}],32:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.AceBaseBase=exports.AceBaseBaseSettings=void 0;const simple_event_emitter_1=require("./simple-event-emitter");const data_reference_1=require("./data-reference");const type_mappings_1=require("./type-mappings");const optional_observable_1=require("./optional-observable");const debug_1=require("./debug");const simple_colors_1=require("./simple-colors");class AceBaseBaseSettings{constructor(options){this.logLevel="log";this.logColors=true;this.info="realtime database";this.sponsor=false;if(typeof options!=="object"){options={}}if(typeof options.logLevel==="string"){this.logLevel=options.logLevel}if(typeof options.logColors==="boolean"){this.logColors=options.logColors}if(typeof options.info==="string"){this.info=options.info}if(typeof options.sponsor==="boolean"){this.sponsor=options.sponsor}}}exports.AceBaseBaseSettings=AceBaseBaseSettings;class AceBaseBase extends simple_event_emitter_1.SimpleEventEmitter{constructor(dbname,options={}){super();this._ready=false;options=new AceBaseBaseSettings(options);this.name=dbname;this.debug=new debug_1.DebugLogger(options.logLevel,`[${dbname}]`);(0,simple_colors_1.SetColorsEnabled)(options.logColors);const logoStyle=[simple_colors_1.ColorStyle.magenta,simple_colors_1.ColorStyle.bold];const logo="     ___          ______                "+"\n"+"    / _ \\         | ___ \\               "+"\n"+"   / /_\\ \\ ___ ___| |_/ / __ _ ___  ___ "+"\n"+"   |  _  |/ __/ _ \\ ___ \\/ _` / __|/ _ \\"+"\n"+"   | | | | (_|  __/ |_/ / (_| \\__ \\  __/"+"\n"+"   \\_| |_/\\___\\___\\____/ \\__,_|___/\\___|";const info=options.info?"".padStart(40-options.info.length," ")+options.info+"\n":"";if(!options.sponsor){this.debug.write(logo.colorize(logoStyle));info&&this.debug.write(info.colorize(simple_colors_1.ColorStyle.magenta))}this.types=new type_mappings_1.TypeMappings(this);this.once("ready",(()=>{this._ready=true}))}async ready(callback){if(!this._ready){await new Promise((resolve=>this.on("ready",resolve)))}callback===null||callback===void 0?void 0:callback()}get isReady(){return this._ready}setObservable(ObservableImpl){(0,optional_observable_1.setObservable)(ObservableImpl)}ref(path){return new data_reference_1.DataReference(this,path)}get root(){return this.ref("")}query(path){const ref=new data_reference_1.DataReference(this,path);return new data_reference_1.DataReferenceQuery(ref)}get indexes(){return{get:()=>this.api.getIndexes(),create:(path,key,options)=>this.api.createIndex(path,key,options),delete:async filePath=>this.api.deleteIndex(filePath)}}get schema(){return{get:path=>this.api.getSchema(path),set:(path,schema,warnOnly=false)=>this.api.setSchema(path,schema,warnOnly),all:()=>this.api.getSchemas(),check:(path,value,isUpdate)=>this.api.validateSchema(path,value,isUpdate)}}}exports.AceBaseBase=AceBaseBase},{"./data-reference":39,"./debug":41,"./optional-observable":45,"./simple-colors":52,"./simple-event-emitter":53,"./type-mappings":57}],33:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.Api=void 0;const simple_event_emitter_1=require("./simple-event-emitter");class NotImplementedError extends Error{constructor(name){super(`${name} is not implemented`)}}class Api extends simple_event_emitter_1.SimpleEventEmitter{constructor(){super()}stats(options){throw new NotImplementedError("stats")}subscribe(path,event,callback,settings){throw new NotImplementedError("subscribe")}unsubscribe(path,event,callback){throw new NotImplementedError("unsubscribe")}update(path,updates,options){throw new NotImplementedError("update")}set(path,value,options){throw new NotImplementedError("set")}get(path,options){throw new NotImplementedError("get")}transaction(path,callback,options){throw new NotImplementedError("transaction")}exists(path){throw new NotImplementedError("exists")}query(path,query,options){throw new NotImplementedError("query")}reflect(path,type,args){throw new NotImplementedError("reflect")}export(path,write,options){throw new NotImplementedError("export")}import(path,read,options){throw new NotImplementedError("import")}createIndex(path,key,options){throw new NotImplementedError("createIndex")}getIndexes(){throw new NotImplementedError("getIndexes")}deleteIndex(filePath){throw new NotImplementedError("deleteIndex")}setSchema(path,schema,warnOnly){throw new NotImplementedError("setSchema")}getSchema(path){throw new NotImplementedError("getSchema")}getSchemas(){throw new NotImplementedError("getSchemas")}validateSchema(path,value,isUpdate){throw new NotImplementedError("validateSchema")}getMutations(filter){throw new NotImplementedError("getMutations")}getChanges(filter){throw new NotImplementedError("getChanges")}}exports.Api=Api},{"./simple-event-emitter":53}],34:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.ascii85=void 0;function c(input,length,result){const b=[0,0,0,0,0];for(let i=0;i<length;i+=4){let n=((input[i]*256+input[i+1])*256+input[i+2])*256+input[i+3];if(!n){result.push("z")}else{for(let j=0;j<5;b[j++]=n%85+33,n=Math.floor(n/85)){}result.push(String.fromCharCode(b[4],b[3],b[2],b[1],b[0]))}}}function encode(arr){const input=arr,result=[],remainder=input.length%4,length=input.length-remainder;c(input,length,result);if(remainder){const t=new Uint8Array(4);t.set(input.slice(length),0);c(t,4,result);let x=result.pop();if(x=="z"){x="!!!!!"}result.push(x.substr(0,remainder+1))}let ret=result.join("");ret="<~"+ret+"~>";return ret}exports.ascii85={encode:function(arr){if(arr instanceof ArrayBuffer){arr=new Uint8Array(arr,0,arr.byteLength)}return encode(arr)},decode:function(input){if(!input.startsWith("<~")||!input.endsWith("~>")){throw new Error("Invalid input string")}input=input.substr(2,input.length-4);const n=input.length,r=[],b=[0,0,0,0,0];let t,x,y,d;for(let i=0;i<n;++i){if(input.charAt(i)=="z"){r.push(0,0,0,0);continue}for(let j=0;j<5;++j){b[j]=input.charCodeAt(i+j)-33}d=n-i;if(d<5){for(let j=d;j<4;b[++j]=0){}b[d]=85}t=(((b[0]*85+b[1])*85+b[2])*85+b[3])*85+b[4];x=t&255;t>>>=8;y=t&255;t>>>=8;r.push(t>>>8,t&255,y,x);for(let j=d;j<5;++j,r.pop()){}i+=4}const data=new Uint8Array(r);return data.buffer.slice(data.byteOffset,data.byteOffset+data.byteLength)}}},{}],35:[function(require,module,exports){"use strict";var _a,_b;Object.defineProperty(exports,"__esModule",{value:true});const pad_1=require("../pad");const env=typeof window==="object"?window:self,globalCount=Object.keys(env).length,mimeTypesLength=(_b=(_a=navigator.mimeTypes)===null||_a===void 0?void 0:_a.length)!==null&&_b!==void 0?_b:0,clientId=(0,pad_1.default)((mimeTypesLength+navigator.userAgent.length).toString(36)+globalCount.toString(36),4);function fingerprint(){return clientId}exports.default=fingerprint},{"../pad":37}],36:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});const fingerprint_1=require("./fingerprint");const pad_1=require("./pad");let c=0;const blockSize=4,base=36,discreteValues=Math.pow(base,blockSize);function randomBlock(){return(0,pad_1.default)((Math.random()*discreteValues<<0).toString(base),blockSize)}function safeCounter(){c=c<discreteValues?c:0;c++;return c-1}function cuid(timebias=0){const letter="c",timestamp=((new Date).getTime()+timebias).toString(base),counter=(0,pad_1.default)(safeCounter().toString(base),blockSize),print=(0,fingerprint_1.default)(),random=randomBlock()+randomBlock();return letter+timestamp+counter+print+random}exports.default=cuid},{"./fingerprint":35,"./pad":37}],37:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});function pad(num,size){const s="000000000"+num;return s.substr(s.length-size)}exports.default=pad},{}],38:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.OrderedCollectionProxy=exports.proxyAccess=exports.LiveDataProxy=void 0;const utils_1=require("./utils");const data_reference_1=require("./data-reference");const data_snapshot_1=require("./data-snapshot");const path_reference_1=require("./path-reference");const id_1=require("./id");const optional_observable_1=require("./optional-observable");const process_1=require("./process");const path_info_1=require("./path-info");const simple_event_emitter_1=require("./simple-event-emitter");class RelativeNodeTarget extends Array{static areEqual(t1,t2){return t1.length===t2.length&&t1.every(((key,i)=>t2[i]===key))}static isAncestor(ancestor,other){return ancestor.length<other.length&&ancestor.every(((key,i)=>other[i]===key))}static isDescendant(descendant,other){return descendant.length>other.length&&other.every(((key,i)=>descendant[i]===key))}}const isProxy=Symbol("isProxy");class LiveDataProxy{static async create(ref,options){var _a;ref=new data_reference_1.DataReference(ref.db,ref.path);let cache,loaded=false;let latestCursor=options===null||options===void 0?void 0:options.cursor;let proxy;const proxyId=id_1.ID.generate();const clientSubscriptions=[];const clientEventEmitter=new simple_event_emitter_1.SimpleEventEmitter;clientEventEmitter.on("cursor",(cursor=>latestCursor=cursor));clientEventEmitter.on("error",(err=>{console.error(err.message,err.details)}));const applyChange=(keys,newValue)=>{if(keys.length===0){cache=newValue;return true}const allowCreation=false;if(allowCreation){cache=typeof keys[0]==="number"?[]:{}}let target=cache;const trailKeys=keys.slice();while(trailKeys.length>1){const key=trailKeys.shift();if(!(key in target)){if(allowCreation){target[key]=typeof key==="number"?[]:{}}else{return false}}target=target[key]}const prop=trailKeys.shift();if(newValue===null){target instanceof Array?target.splice(prop,1):delete target[prop]}else{target[prop]=newValue}return true};const syncFallback=async()=>{if(!loaded){return}await reload()};const subscription=ref.on("mutations",{syncFallback:syncFallback}).subscribe((async snap=>{var _a;if(!loaded){return}const context=snap.context();const isRemote=((_a=context.acebase_proxy)===null||_a===void 0?void 0:_a.id)!==proxyId;if(!isRemote){return}const mutations=snap.val(false);const proceed=mutations.every((mutation=>{if(!applyChange(mutation.target,mutation.val)){return false}const changeRef=mutation.target.reduce(((ref,key)=>ref.child(key)),ref);const changeSnap=new data_snapshot_1.DataSnapshot(changeRef,mutation.val,false,mutation.prev,snap.context());clientEventEmitter.emit("mutation",{snapshot:changeSnap,isRemote:isRemote});return true}));if(proceed){clientEventEmitter.emit("cursor",context.acebase_cursor);localMutationsEmitter.emit("mutations",{origin:"remote",snap:snap})}else{console.warn(`Cached value of live data proxy on "${ref.path}" appears outdated, will be reloaded`);await reload()}}));let processPromise=Promise.resolve();const mutationQueue=[];const transactions=[];const pushLocalMutations=async()=>{const mutations=[];for(let i=0,m=mutationQueue[0];i<mutationQueue.length;i++,m=mutationQueue[i]){if(!transactions.find((t=>RelativeNodeTarget.areEqual(t.target,m.target)||RelativeNodeTarget.isAncestor(t.target,m.target)))){mutationQueue.splice(i,1);i--;mutations.push(m)}}if(mutations.length===0){return}mutations.forEach((mutation=>{mutation.value=(0,utils_1.cloneObject)(getTargetValue(cache,mutation.target))}));process_1.default.nextTick((()=>{const context={acebase_proxy:{id:proxyId,source:"update"}};mutations.forEach((mutation=>{const mutationRef=mutation.target.reduce(((ref,key)=>ref.child(key)),ref);const mutationSnap=new data_snapshot_1.DataSnapshot(mutationRef,mutation.value,false,mutation.previous,context);clientEventEmitter.emit("mutation",{snapshot:mutationSnap,isRemote:false})}));const snap=new data_snapshot_1.MutationsDataSnapshot(ref,mutations.map((m=>({target:m.target,val:m.value,prev:m.previous}))),context);localMutationsEmitter.emit("mutations",{origin:"local",snap:snap})}));processPromise=mutations.reduce(((mutations,m,i,arr)=>{if(!arr.some((other=>RelativeNodeTarget.isAncestor(other.target,m.target)))){mutations.push(m)}return mutations}),[]).reduce(((updates,m)=>{const target=m.target;if(target.length===0){updates.push({ref:ref,target:target,value:cache,type:"set",previous:m.previous})}else{const parentTarget=target.slice(0,-1);const key=target.slice(-1)[0];const parentRef=parentTarget.reduce(((ref,key)=>ref.child(key)),ref);const parentUpdate=updates.find((update=>update.ref.path===parentRef.path));const cacheValue=getTargetValue(cache,target);const prevValue=m.previous;if(parentUpdate){parentUpdate.value[key]=cacheValue;parentUpdate.previous[key]=prevValue}else{updates.push({ref:parentRef,target:parentTarget,value:{[key]:cacheValue},type:"update",previous:{[key]:prevValue}})}}return updates}),[]).reduce((async(promise,update)=>{const context={acebase_proxy:{id:proxyId,source:update.type}};await promise;await update.ref.context(context)[update.type](update.value).catch((err=>{clientEventEmitter.emit("error",{source:"update",message:`Error processing update of "/${ref.path}"`,details:err});const context={acebase_proxy:{id:proxyId,source:"update-rollback"}};const mutations=[];if(update.type==="set"){setTargetValue(cache,update.target,update.previous);const mutationSnap=new data_snapshot_1.DataSnapshot(update.ref,update.previous,false,update.value,context);clientEventEmitter.emit("mutation",{snapshot:mutationSnap,isRemote:false});mutations.push({target:update.target,val:update.previous,prev:update.value})}else{Object.keys(update.previous).forEach((key=>{setTargetValue(cache,update.target.concat(key),update.previous[key]);const mutationSnap=new data_snapshot_1.DataSnapshot(update.ref.child(key),update.previous[key],false,update.value[key],context);clientEventEmitter.emit("mutation",{snapshot:mutationSnap,isRemote:false});mutations.push({target:update.target.concat(key),val:update.previous[key],prev:update.value[key]})}))}mutations.forEach((m=>{const mutationRef=m.target.reduce(((ref,key)=>ref.child(key)),ref);const mutationSnap=new data_snapshot_1.DataSnapshot(mutationRef,m.val,false,m.prev,context);clientEventEmitter.emit("mutation",{snapshot:mutationSnap,isRemote:false})}));const snap=new data_snapshot_1.MutationsDataSnapshot(update.ref,mutations,context);localMutationsEmitter.emit("mutations",{origin:"local",snap:snap})}));if(update.ref.cursor){clientEventEmitter.emit("cursor",update.ref.cursor)}}),processPromise);await processPromise};let syncInProgress=false;const syncPromises=[];const syncCompleted=()=>{let resolve;const promise=new Promise((rs=>resolve=rs));syncPromises.push({resolve:resolve});return promise};let processQueueTimeout=null;const scheduleSync=()=>{if(!processQueueTimeout){processQueueTimeout=setTimeout((async()=>{syncInProgress=true;processQueueTimeout=null;await pushLocalMutations();syncInProgress=false;syncPromises.splice(0).forEach((p=>p.resolve()))}),0)}};const flagOverwritten=target=>{if(!mutationQueue.find((m=>RelativeNodeTarget.areEqual(m.target,target)))){mutationQueue.push({target:target,previous:(0,utils_1.cloneObject)(getTargetValue(cache,target))})}scheduleSync()};const localMutationsEmitter=new simple_event_emitter_1.SimpleEventEmitter;const addOnChangeHandler=(target,callback)=>{const isObject=val=>val!==null&&typeof val==="object";const mutationsHandler=async details=>{var _a;const{snap:snap,origin:origin}=details;const context=snap.context();const causedByOurProxy=((_a=context.acebase_proxy)===null||_a===void 0?void 0:_a.id)===proxyId;if(details.origin==="remote"&&causedByOurProxy){console.error("DEV ISSUE: mutationsHandler was called from remote event originating from our own proxy");return}const mutations=snap.val(false).filter((mutation=>mutation.target.slice(0,target.length).every(((key,i)=>target[i]===key))));if(mutations.length===0){return}let newValue,previousValue;const singleMutation=mutations.find((m=>m.target.length<=target.length));if(singleMutation){const trailKeys=target.slice(singleMutation.target.length);newValue=trailKeys.reduce(((val,key)=>!isObject(val)||!(key in val)?null:val[key]),singleMutation.val);previousValue=trailKeys.reduce(((val,key)=>!isObject(val)||!(key in val)?null:val[key]),singleMutation.prev)}else{const currentValue=getTargetValue(cache,target);newValue=(0,utils_1.cloneObject)(currentValue);previousValue=(0,utils_1.cloneObject)(newValue);mutations.forEach((mutation=>{const trailKeys=mutation.target.slice(target.length);for(let i=0,val=newValue,prev=previousValue;i<trailKeys.length;i++){const last=i+1===trailKeys.length,key=trailKeys[i];if(last){val[key]=mutation.val;if(val[key]===null){delete val[key]}prev[key]=mutation.prev;if(prev[key]===null){delete prev[key]}}else{val=val[key]=key in val?val[key]:{};prev=prev[key]=key in prev?prev[key]:{}}}}))}process_1.default.nextTick((()=>{let keepSubscription=true;try{keepSubscription=false!==callback(Object.freeze(newValue),Object.freeze(previousValue),!causedByOurProxy,context)}catch(err){clientEventEmitter.emit("error",{source:origin==="remote"?"remote_update":"local_update",message:"Error running subscription callback",details:err})}if(keepSubscription===false){stop()}}))};localMutationsEmitter.on("mutations",mutationsHandler);const stop=()=>{localMutationsEmitter.off("mutations",mutationsHandler);clientSubscriptions.splice(clientSubscriptions.findIndex((cs=>cs.stop===stop)),1)};clientSubscriptions.push({target:target,stop:stop});return{stop:stop}};const handleFlag=(flag,target,args)=>{if(flag==="write"){return flagOverwritten(target)}else if(flag==="onChange"){return addOnChangeHandler(target,args.callback)}else if(flag==="subscribe"||flag==="observe"){const subscribe=subscriber=>{const currentValue=getTargetValue(cache,target);subscriber.next(currentValue);const subscription=addOnChangeHandler(target,(value=>{subscriber.next(value)}));return function unsubscribe(){subscription.stop()}};if(flag==="subscribe"){return subscribe}const Observable=(0,optional_observable_1.getObservable)();return new Observable(subscribe)}else if(flag==="transaction"){const hasConflictingTransaction=transactions.some((t=>RelativeNodeTarget.areEqual(target,t.target)||RelativeNodeTarget.isAncestor(target,t.target)||RelativeNodeTarget.isDescendant(target,t.target)));if(hasConflictingTransaction){return Promise.reject(new Error("Cannot start transaction because it conflicts with another transaction"))}return new Promise((async resolve=>{const hasPendingMutations=mutationQueue.some((m=>RelativeNodeTarget.areEqual(target,m.target)||RelativeNodeTarget.isAncestor(target,m.target)));if(hasPendingMutations){if(!syncInProgress){scheduleSync()}await syncCompleted()}const tx={target:target,status:"started",transaction:null};transactions.push(tx);tx.transaction={get status(){return tx.status},get completed(){return tx.status!=="started"},get mutations(){return mutationQueue.filter((m=>RelativeNodeTarget.areEqual(tx.target,m.target)||RelativeNodeTarget.isAncestor(tx.target,m.target)))},get hasMutations(){return this.mutations.length>0},async commit(){if(this.completed){throw new Error(`Transaction has completed already (status '${tx.status}')`)}tx.status="finished";transactions.splice(transactions.indexOf(tx),1);if(syncInProgress){await syncCompleted()}scheduleSync();await syncCompleted()},rollback(){if(this.completed){throw new Error(`Transaction has completed already (status '${tx.status}')`)}tx.status="canceled";const mutations=[];for(let i=0;i<mutationQueue.length;i++){const m=mutationQueue[i];if(RelativeNodeTarget.areEqual(tx.target,m.target)||RelativeNodeTarget.isAncestor(tx.target,m.target)){mutationQueue.splice(i,1);i--;mutations.push(m)}}mutations.reverse().forEach((m=>{if(m.target.length===0){cache=m.previous}else{setTargetValue(cache,m.target,m.previous)}}));transactions.splice(transactions.indexOf(tx),1)}};resolve(tx.transaction)}))}};const snap=await ref.get({cache_mode:"allow",cache_cursor:options===null||options===void 0?void 0:options.cursor});if(snap.context().acebase_origin!=="cache"){clientEventEmitter.emit("cursor",(_a=ref.cursor)!==null&&_a!==void 0?_a:null)}loaded=true;cache=snap.val();if(cache===null&&typeof(options===null||options===void 0?void 0:options.defaultValue)!=="undefined"){cache=options.defaultValue;const context={acebase_proxy:{id:proxyId,source:"default"}};await ref.context(context).set(cache)}proxy=createProxy({root:{ref:ref,get cache(){return cache}},target:[],id:proxyId,flag:handleFlag});const assertProxyAvailable=()=>{if(proxy===null){throw new Error("Proxy was destroyed")}};const reload=async()=>{assertProxyAvailable();mutationQueue.splice(0);const snap=await ref.get({allow_cache:false});const oldVal=cache,newVal=snap.val();cache=newVal;const mutations=(0,utils_1.getMutations)(oldVal,newVal);if(mutations.length===0){return}const context=snap.context();context.acebase_proxy={id:proxyId,source:"reload"};mutations.forEach((m=>{const targetRef=getTargetRef(ref,m.target);const newSnap=new data_snapshot_1.DataSnapshot(targetRef,m.val,m.val===null,m.prev,context);clientEventEmitter.emit("mutation",{snapshot:newSnap,isRemote:true})}));const mutationsSnap=new data_snapshot_1.MutationsDataSnapshot(ref,mutations,context);localMutationsEmitter.emit("mutations",{origin:"local",snap:mutationsSnap})};return{async destroy(){await processPromise;const promises=[subscription.stop(),...clientSubscriptions.map((cs=>cs.stop()))];await Promise.all(promises);["cursor","mutation","error"].forEach((event=>clientEventEmitter.off(event)));cache=null;proxy=null},stop(){this.destroy()},get value(){assertProxyAvailable();return proxy},get hasValue(){assertProxyAvailable();return cache!==null},set value(val){assertProxyAvailable();if(val!==null&&typeof val==="object"&&val[isProxy]){val=val.valueOf()}flagOverwritten([]);cache=val},get ref(){return ref},get cursor(){return latestCursor},reload:reload,onMutation(callback){assertProxyAvailable();clientEventEmitter.off("mutation");clientEventEmitter.on("mutation",(({snapshot:snapshot,isRemote:isRemote})=>{try{callback(snapshot,isRemote)}catch(err){clientEventEmitter.emit("error",{source:"mutation_callback",message:"Error in dataproxy onMutation callback",details:err})}}))},onError(callback){assertProxyAvailable();clientEventEmitter.off("error");clientEventEmitter.on("error",(err=>{try{callback(err)}catch(err){console.error(`Error in dataproxy onError callback: ${err.message}`)}}))},on(event,callback){clientEventEmitter.on(event,callback)},off(event,callback){clientEventEmitter.off(event,callback)}}}}exports.LiveDataProxy=LiveDataProxy;function getTargetValue(obj,target){let val=obj;for(const key of target){val=typeof val==="object"&&val!==null&&key in val?val[key]:null}return val}function setTargetValue(obj,target,value){if(target.length===0){throw new Error("Cannot update root target, caller must do that itself!")}const targetObject=target.slice(0,-1).reduce(((obj,key)=>obj[key]),obj);const prop=target.slice(-1)[0];if(value===null||typeof value==="undefined"){targetObject instanceof Array?targetObject.splice(prop,1):delete targetObject[prop]}else{targetObject[prop]=value}}function getTargetRef(ref,target){const path=path_info_1.PathInfo.get(ref.path).childPath(target);return new data_reference_1.DataReference(ref.db,path)}function createProxy(context){const targetRef=getTargetRef(context.root.ref,context.target);const childProxies=[];const handler={get(target,prop,receiver){target=getTargetValue(context.root.cache,context.target);if(typeof prop==="symbol"){if(prop.toString()===Symbol.iterator.toString()){prop="values"}else if(prop.toString()===isProxy.toString()){return true}else{return Reflect.get(target,prop,receiver)}}if(prop==="valueOf"){return function valueOf(){return target}}if(target===null||typeof target!=="object"){throw new Error(`Cannot read property "${prop}" of ${target}. Value of path "/${targetRef.path}" is not an object (anymore)`)}if(target instanceof Array&&typeof prop==="string"&&/^[0-9]+$/.test(prop)){prop=parseInt(prop)}const value=target[prop];if(value===null){delete target[prop];return}const childProxy=childProxies.find((proxy=>proxy.prop===prop));if(childProxy){if(childProxy.typeof===typeof value){return childProxy.value}childProxies.splice(childProxies.indexOf(childProxy),1)}const proxifyChildValue=prop=>{const value=target[prop];const childProxy=childProxies.find((child=>child.prop===prop));if(childProxy){if(childProxy.typeof===typeof value){return childProxy.value}childProxies.splice(childProxies.indexOf(childProxy),1)}if(typeof value!=="object"){return value}const newChildProxy=createProxy({root:context.root,target:context.target.concat(prop),id:context.id,flag:context.flag});childProxies.push({typeof:typeof value,prop:prop,value:newChildProxy});return newChildProxy};const unproxyValue=value=>value!==null&&typeof value==="object"&&value[isProxy]?value.getTarget():value;if(["string","number","boolean"].includes(typeof value)||value instanceof Date||value instanceof path_reference_1.PathReference||value instanceof ArrayBuffer||typeof value==="object"&&"buffer"in value){return value}const isArray=target instanceof Array;if(prop==="toString"){return function toString(){return`[LiveDataProxy for "${targetRef.path}"]`}}if(typeof value==="undefined"){if(prop==="push"){return function push(item){const childRef=targetRef.push();context.flag("write",context.target.concat(childRef.key));target[childRef.key]=item;return childRef.key}}if(prop==="getTarget"){return function(warn=true){warn&&console.warn("Use getTarget with caution - any changes will not be synchronized!");return target}}if(prop==="getRef"){return function getRef(){const ref=getTargetRef(context.root.ref,context.target);return ref}}if(prop==="forEach"){return function forEach(callback){const keys=Object.keys(target);let stop=false;for(let i=0;!stop&&i<keys.length;i++){const key=keys[i];const value=proxifyChildValue(key);stop=callback(value,key,i)===false}}}if(["values","entries","keys"].includes(prop)){return function*generator(){const keys=Object.keys(target);for(const key of keys){if(prop==="keys"){yield key}else{const value=proxifyChildValue(key);if(prop==="entries"){yield[key,value]}else{yield value}}}}}if(prop==="toArray"){return function toArray(sortFn){const arr=Object.keys(target).map((key=>proxifyChildValue(key)));if(sortFn){arr.sort(sortFn)}return arr}}if(prop==="onChanged"){return function onChanged(callback){return context.flag("onChange",context.target,{callback:callback})}}if(prop==="subscribe"){return function subscribe(){return context.flag("subscribe",context.target)}}if(prop==="getObservable"){return function getObservable(){return context.flag("observe",context.target)}}if(prop==="getOrderedCollection"){return function getOrderedCollection(orderProperty,orderIncrement){return new OrderedCollectionProxy(this,orderProperty,orderIncrement)}}if(prop==="startTransaction"){return function startTransaction(){return context.flag("transaction",context.target)}}if(prop==="remove"&&!isArray){return function remove(){if(context.target.length===0){throw new Error("Can't remove proxy root value")}const parent=getTargetValue(context.root.cache,context.target.slice(0,-1));const key=context.target.slice(-1)[0];context.flag("write",context.target);delete parent[key]}}return}else if(typeof value==="function"){if(isArray){const writeArray=action=>{context.flag("write",context.target);return action()};const cleanArrayValues=values=>values.map((value=>{value=unproxyValue(value);removeVoidProperties(value);return value}));if(prop==="push"){return function push(...items){items=cleanArrayValues(items);return writeArray((()=>target.push(...items)))}}if(prop==="pop"){return function pop(){return writeArray((()=>target.pop()))}}if(prop==="splice"){return function splice(start,deleteCount,...items){items=cleanArrayValues(items);return writeArray((()=>target.splice(start,deleteCount,...items)))}}if(prop==="shift"){return function shift(){return writeArray((()=>target.shift()))}}if(prop==="unshift"){return function unshift(...items){items=cleanArrayValues(items);return writeArray((()=>target.unshift(...items)))}}if(prop==="sort"){return function sort(compareFn){return writeArray((()=>target.sort(compareFn)))}}if(prop==="reverse"){return function reverse(){return writeArray((()=>target.reverse()))}}if(["indexOf","lastIndexOf"].includes(prop)){return function indexOf(item,start){if(item!==null&&typeof item==="object"&&item[isProxy]){item=item.getTarget(false)}return target[prop](item,start)}}if(["forEach","every","some","filter","map"].includes(prop)){return function iterate(callback){return target[prop](((value,i)=>callback(proxifyChildValue(i),i,proxy)))}}if(["reduce","reduceRight"].includes(prop)){return function reduce(callback,initialValue){return target[prop](((prev,value,i)=>callback(prev,proxifyChildValue(i),i,proxy)),initialValue)}}if(["find","findIndex"].includes(prop)){return function find(callback){let value=target[prop](((value,i)=>callback(proxifyChildValue(i),i,proxy)));if(prop==="find"&&value){const index=target.indexOf(value);value=proxifyChildValue(index)}return value}}if(["values","entries","keys"].includes(prop)){return function*generator(){for(let i=0;i<target.length;i++){if(prop==="keys"){yield i}else{const value=proxifyChildValue(i);if(prop==="entries"){yield[i,value]}else{yield value}}}}}}return value}return proxifyChildValue(prop)},set(target,prop,value,receiver){target=getTargetValue(context.root.cache,context.target);if(typeof prop==="symbol"){return Reflect.set(target,prop,value,receiver)}if(target===null||typeof target!=="object"){throw new Error(`Cannot set property "${prop}" of ${target}. Value of path "/${targetRef.path}" is not an object`)}if(target instanceof Array&&typeof prop==="string"){if(!/^[0-9]+$/.test(prop)){throw new Error(`Cannot set property "${prop}" on array value of path "/${targetRef.path}"`)}prop=parseInt(prop)}if(value!==null){if(typeof value==="object"){if(value[isProxy]){value=value.valueOf()}value=(0,utils_1.cloneObject)(value)}if((0,utils_1.valuesAreEqual)(value,target[prop])){return true}}if(context.target.some((key=>typeof key==="number"))){context.flag("write",context.target.slice(0,context.target.findIndex((key=>typeof key==="number"))))}else if(target instanceof Array){context.flag("write",context.target)}else{context.flag("write",context.target.concat(prop))}if(value===null){delete target[prop]}else{removeVoidProperties(value);target[prop]=value}return true},deleteProperty(target,prop){target=getTargetValue(context.root.cache,context.target);if(target===null){throw new Error(`Cannot delete property ${prop.toString()} of null`)}if(typeof prop==="symbol"){return Reflect.deleteProperty(target,prop)}if(!(prop in target)){return true}context.flag("write",context.target.concat(prop));delete target[prop];return true},ownKeys(target){target=getTargetValue(context.root.cache,context.target);return Reflect.ownKeys(target)},has(target,prop){target=getTargetValue(context.root.cache,context.target);return Reflect.has(target,prop)},getOwnPropertyDescriptor(target,prop){target=getTargetValue(context.root.cache,context.target);const descriptor=Reflect.getOwnPropertyDescriptor(target,prop);if(descriptor){descriptor.configurable=true}return descriptor},getPrototypeOf(target){target=getTargetValue(context.root.cache,context.target);return Reflect.getPrototypeOf(target)}};const proxy=new Proxy({},handler);return proxy}function removeVoidProperties(obj){if(typeof obj!=="object"){return}Object.keys(obj).forEach((key=>{const val=obj[key];if(val===null||typeof val==="undefined"){delete obj[key]}else if(typeof val==="object"){removeVoidProperties(val)}}))}function proxyAccess(proxiedValue){if(typeof proxiedValue!=="object"||!proxiedValue[isProxy]){throw new Error("Given value is not proxied. Make sure you are referencing the value through the live data proxy.")}return proxiedValue}exports.proxyAccess=proxyAccess;class OrderedCollectionProxy{constructor(collection,orderProperty="order",orderIncrement=10){this.collection=collection;this.orderProperty=orderProperty;this.orderIncrement=orderIncrement;if(typeof collection!=="object"||!collection[isProxy]){throw new Error("Collection is not proxied")}if(collection.valueOf()instanceof Array){throw new Error("Collection is an array, not an object collection")}if(!Object.keys(collection).every((key=>typeof collection[key]==="object"))){throw new Error("Collection has non-object children")}const ok=Object.keys(collection).every((key=>typeof collection[key][orderProperty]==="number"));if(!ok){const keys=Object.keys(collection);for(let i=0;i<keys.length;i++){const item=collection[keys[i]];item[orderProperty]=i*orderIncrement}}}getObservable(){return proxyAccess(this.collection).getObservable()}getArrayObservable(){const Observable=(0,optional_observable_1.getObservable)();return new Observable((subscriber=>{const subscription=this.getObservable().subscribe((()=>{const newArray=this.getArray();subscriber.next(newArray)}));return function unsubscribe(){subscription.unsubscribe()}}))}getArray(){const arr=proxyAccess(this.collection).toArray(((a,b)=>a[this.orderProperty]-b[this.orderProperty]));return arr}add(item,index,from){const arr=this.getArray();let minOrder=Number.POSITIVE_INFINITY,maxOrder=Number.NEGATIVE_INFINITY;for(let i=0;i<arr.length;i++){const order=arr[i][this.orderProperty];minOrder=Math.min(order,minOrder);maxOrder=Math.max(order,maxOrder)}let fromKey;if(typeof from==="number"){fromKey=Object.keys(this.collection).find((key=>this.collection[key]===item));if(!fromKey){throw new Error("item not found in collection")}if(from===index){return{key:fromKey,index:index}}if(Math.abs(from-index)===1){const otherItem=arr[index];const otherOrder=otherItem[this.orderProperty];otherItem[this.orderProperty]=item[this.orderProperty];item[this.orderProperty]=otherOrder;return{key:fromKey,index:index}}else{arr.splice(from,1)}}if(typeof index!=="number"||index>=arr.length){index=arr.length;item[this.orderProperty]=arr.length==0?0:maxOrder+this.orderIncrement}else if(index===0){item[this.orderProperty]=arr.length==0?0:minOrder-this.orderIncrement}else{const orders=arr.map((item=>item[this.orderProperty]));const gap=orders[index]-orders[index-1];if(gap>1){item[this.orderProperty]=orders[index]-Math.floor(gap/2)}else{arr.splice(index,0,item);for(let i=0;i<arr.length;i++){arr[i][this.orderProperty]=i*this.orderIncrement}}}const key=typeof fromKey==="string"?fromKey:proxyAccess(this.collection).push(item);return{key:key,index:index}}delete(index){const arr=this.getArray();const item=arr[index];if(!item){throw new Error(`Item at index ${index} not found`)}const key=Object.keys(this.collection).find((key=>this.collection[key]===item));if(!key){throw new Error("Cannot find target object to delete")}this.collection[key]=null;return{key:key,index:index}}move(fromIndex,toIndex){const arr=this.getArray();return this.add(arr[fromIndex],toIndex,fromIndex)}sort(sortFn){const arr=this.getArray();arr.sort(sortFn);for(let i=0;i<arr.length;i++){arr[i][this.orderProperty]=i*this.orderIncrement}}}exports.OrderedCollectionProxy=OrderedCollectionProxy},{"./data-reference":39,"./data-snapshot":40,"./id":42,"./optional-observable":45,"./path-info":47,"./path-reference":48,"./process":49,"./simple-event-emitter":53,"./utils":58}],39:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.DataReferencesArray=exports.DataSnapshotsArray=exports.DataReferenceQuery=exports.DataReference=exports.QueryDataRetrievalOptions=exports.DataRetrievalOptions=void 0;const data_snapshot_1=require("./data-snapshot");const subscription_1=require("./subscription");const id_1=require("./id");const path_info_1=require("./path-info");const data_proxy_1=require("./data-proxy");const optional_observable_1=require("./optional-observable");class DataRetrievalOptions{constructor(options){if(!options){options={}}if(typeof options.include!=="undefined"&&!(options.include instanceof Array)){throw new TypeError("options.include must be an array")}if(typeof options.exclude!=="undefined"&&!(options.exclude instanceof Array)){throw new TypeError("options.exclude must be an array")}if(typeof options.child_objects!=="undefined"&&typeof options.child_objects!=="boolean"){throw new TypeError("options.child_objects must be a boolean")}if(typeof options.cache_mode==="string"&&!["allow","bypass","force"].includes(options.cache_mode)){throw new TypeError("invalid value for options.cache_mode")}this.include=options.include||undefined;this.exclude=options.exclude||undefined;this.child_objects=typeof options.child_objects==="boolean"?options.child_objects:undefined;this.cache_mode=typeof options.cache_mode==="string"?options.cache_mode:typeof options.allow_cache==="boolean"?options.allow_cache?"allow":"bypass":"allow";this.cache_cursor=typeof options.cache_cursor==="string"?options.cache_cursor:undefined}}exports.DataRetrievalOptions=DataRetrievalOptions;class QueryDataRetrievalOptions extends DataRetrievalOptions{constructor(options){super(options);if(!["undefined","boolean"].includes(typeof options.snapshots)){throw new TypeError("options.snapshots must be a boolean")}this.snapshots=typeof options.snapshots==="boolean"?options.snapshots:true}}exports.QueryDataRetrievalOptions=QueryDataRetrievalOptions;const _private=Symbol("private");class DataReference{constructor(db,path,vars){this.db=db;if(!path){path=""}path=path.replace(/^\/|\/$/g,"");const pathInfo=path_info_1.PathInfo.get(path);const key=pathInfo.key;const callbacks=[];this[_private]={get path(){return path},get key(){return key},get callbacks(){return callbacks},vars:vars||{},context:{},pushed:false,cursor:null}}context(context,merge=false){const currentContext=this[_private].context;if(typeof context==="object"){const newContext=context?merge?currentContext||{}:context:{};if(context){Object.keys(context).forEach((key=>{newContext[key]=context[key]}))}this[_private].context=newContext;return this}else if(typeof context==="undefined"){console.warn("Use snap.context() instead of snap.ref.context() to get updating context in event callbacks");return currentContext}else{throw new Error("Invalid context argument")}}get cursor(){return this[_private].cursor}set cursor(value){var _a;this[_private].cursor=value;(_a=this.onCursor)===null||_a===void 0?void 0:_a.call(this,value)}get path(){return this[_private].path}get key(){const key=this[_private].key;return typeof key==="number"?`[${key}]`:key}get index(){const key=this[_private].key;if(typeof key!=="number"){throw new Error(`"${key}" is not a number`)}return key}get parent(){const currentPath=path_info_1.PathInfo.fillVariables2(this.path,this.vars);const info=path_info_1.PathInfo.get(currentPath);if(info.parentPath===null){return null}return new DataReference(this.db,info.parentPath).context(this[_private].context)}get vars(){return this[_private].vars}child(childPath){childPath=typeof childPath==="number"?childPath:childPath.replace(/^\/|\/$/g,"");const currentPath=path_info_1.PathInfo.fillVariables2(this.path,this.vars);const targetPath=path_info_1.PathInfo.getChildPath(currentPath,childPath);return new DataReference(this.db,targetPath).context(this[_private].context)}async set(value,onComplete){try{if(this.isWildcardPath){throw new Error(`Cannot set the value of wildcard path "/${this.path}"`)}if(this.parent===null){throw new Error("Cannot set the root object. Use update, or set individual child properties")}if(typeof value==="undefined"){throw new TypeError(`Cannot store undefined value in "/${this.path}"`)}if(!this.db.isReady){await this.db.ready()}value=this.db.types.serialize(this.path,value);const{cursor:cursor}=await this.db.api.set(this.path,value,{context:this[_private].context});this.cursor=cursor;if(typeof onComplete==="function"){try{onComplete(null,this)}catch(err){console.error("Error in onComplete callback:",err)}}}catch(err){if(typeof onComplete==="function"){try{onComplete(err,this)}catch(err){console.error("Error in onComplete callback:",err)}}else{throw err}}return this}async update(updates,onComplete){try{if(this.isWildcardPath){throw new Error(`Cannot update the value of wildcard path "/${this.path}"`)}if(!this.db.isReady){await this.db.ready()}if(typeof updates!=="object"||updates instanceof Array||updates instanceof ArrayBuffer||updates instanceof Date){await this.set(updates)}else if(Object.keys(updates).length===0){console.warn(`update called on path "/${this.path}", but there is nothing to update`)}else{updates=this.db.types.serialize(this.path,updates);const{cursor:cursor}=await this.db.api.update(this.path,updates,{context:this[_private].context});this.cursor=cursor}if(typeof onComplete==="function"){try{onComplete(null,this)}catch(err){console.error("Error in onComplete callback:",err)}}}catch(err){if(typeof onComplete==="function"){try{onComplete(err,this)}catch(err){console.error("Error in onComplete callback:",err)}}else{throw err}}return this}async transaction(callback){if(this.isWildcardPath){throw new Error(`Cannot start a transaction on wildcard path "/${this.path}"`)}if(!this.db.isReady){await this.db.ready()}let throwError;const cb=currentValue=>{currentValue=this.db.types.deserialize(this.path,currentValue);const snap=new data_snapshot_1.DataSnapshot(this,currentValue);let newValue;try{newValue=callback(snap)}catch(err){throwError=err;return}if(newValue instanceof Promise){return newValue.then((val=>this.db.types.serialize(this.path,val))).catch((err=>{throwError=err;return}))}else{return this.db.types.serialize(this.path,newValue)}};const{cursor:cursor}=await this.db.api.transaction(this.path,cb,{context:this[_private].context});this.cursor=cursor;if(throwError){throw throwError}return this}on(event,callback,cancelCallback){if(this.path===""&&["value","child_changed"].includes(event)){console.warn("WARNING: Listening for value and child_changed events on the root node is a bad practice. These events require loading of all data (value event), or potentially lots of data (child_changed event) each time they are fired")}let eventPublisher=null;const eventStream=new subscription_1.EventStream((publisher=>{eventPublisher=publisher}));const cb={event:event,stream:eventStream,userCallback:typeof callback==="function"&&callback,ourCallback:(err,path,newValue,oldValue,eventContext)=>{if(err){this.db.debug.error(`Error getting data for event ${event} on path "${path}"`,err);return}const ref=this.db.ref(path);ref[_private].vars=path_info_1.PathInfo.extractVariables(this.path,path);let callbackObject;if(event.startsWith("notify_")){callbackObject=ref.context(eventContext||{})}else{const values={previous:this.db.types.deserialize(path,oldValue),current:this.db.types.deserialize(path,newValue)};if(event==="child_removed"){callbackObject=new data_snapshot_1.DataSnapshot(ref,values.previous,true,values.previous,eventContext)}else if(event==="mutations"){callbackObject=new data_snapshot_1.MutationsDataSnapshot(ref,values.current,eventContext)}else{const isRemoved=event==="mutated"&&values.current===null;callbackObject=new data_snapshot_1.DataSnapshot(ref,values.current,isRemoved,values.previous,eventContext)}}eventPublisher.publish(callbackObject);if(eventContext===null||eventContext===void 0?void 0:eventContext.acebase_cursor){this.cursor=eventContext.acebase_cursor}}};this[_private].callbacks.push(cb);const subscribe=()=>{if(typeof callback==="function"){eventStream.subscribe(callback,((activated,cancelReason)=>{if(!activated){cancelCallback&&cancelCallback(cancelReason)}}))}const advancedOptions=typeof callback==="object"?callback:{newOnly:!callback};if(typeof advancedOptions.newOnly!=="boolean"){advancedOptions.newOnly=false}if(this.isWildcardPath){advancedOptions.newOnly=true}const cancelSubscription=err=>{const callbacks=this[_private].callbacks;callbacks.splice(callbacks.indexOf(cb),1);this.db.api.unsubscribe(this.path,event,cb.ourCallback);this.db.debug.error(`Subscription "${event}" on path "/${this.path}" canceled because of an error: ${err.message}`);eventPublisher.cancel(err.message)};const authorized=this.db.api.subscribe(this.path,event,cb.ourCallback,{newOnly:advancedOptions.newOnly,cancelCallback:cancelSubscription,syncFallback:advancedOptions.syncFallback});const allSubscriptionsStoppedCallback=()=>{const callbacks=this[_private].callbacks;callbacks.splice(callbacks.indexOf(cb),1);return this.db.api.unsubscribe(this.path,event,cb.ourCallback)};if(authorized instanceof Promise){authorized.then((()=>{eventPublisher.start(allSubscriptionsStoppedCallback)})).catch(cancelSubscription)}else{eventPublisher.start(allSubscriptionsStoppedCallback)}if(!advancedOptions.newOnly){if(event==="value"){this.get((snap=>{eventPublisher.publish(snap)}))}else if(event==="child_added"){this.get((snap=>{const val=snap.val();if(val===null||typeof val!=="object"){return}Object.keys(val).forEach((key=>{const childSnap=new data_snapshot_1.DataSnapshot(this.child(key),val[key]);eventPublisher.publish(childSnap)}))}))}else if(event==="notify_child_added"){const step=100,limit=step;let skip=0;const more=async()=>{const children=await this.db.api.reflect(this.path,"children",{limit:limit,skip:skip});children.list.forEach((child=>{const childRef=this.child(child.key);eventPublisher.publish(childRef)}));if(children.more){skip+=step;more()}};more()}}};if(this.db.isReady){subscribe()}else{this.db.ready(subscribe)}return eventStream}off(event,callback){const subscriptions=this[_private].callbacks;const stopSubs=subscriptions.filter((sub=>(!event||sub.event===event)&&(!callback||sub.userCallback===callback)));if(stopSubs.length===0){this.db.debug.warn(`Can't find event subscriptions to stop (path: "${this.path}", event: ${event||"(any)"}, callback: ${callback})`)}stopSubs.forEach((sub=>{sub.stream.stop()}));return this}get(optionsOrCallback,callback){if(!this.db.isReady){const promise=this.db.ready().then((()=>this.get(optionsOrCallback,callback)));return typeof optionsOrCallback!=="function"&&typeof callback!=="function"?promise:undefined}callback=typeof optionsOrCallback==="function"?optionsOrCallback:typeof callback==="function"?callback:undefined;if(this.isWildcardPath){const error=new Error(`Cannot get value of wildcard path "/${this.path}". Use .query() instead`);if(typeof callback==="function"){throw error}return Promise.reject(error)}const options=new DataRetrievalOptions(typeof optionsOrCallback==="object"?optionsOrCallback:{cache_mode:"allow"});const promise=this.db.api.get(this.path,options).then((result=>{var _a;const isNewApiResult="context"in result&&"value"in result;if(!isNewApiResult){console.warn("AceBase api.get method returned an old response value. Update your acebase or acebase-client package");result={value:result,context:{}}}const value=this.db.types.deserialize(this.path,result.value);const snapshot=new data_snapshot_1.DataSnapshot(this,value,undefined,undefined,result.context);if((_a=result.context)===null||_a===void 0?void 0:_a.acebase_cursor){this.cursor=result.context.acebase_cursor}return snapshot}));if(callback){promise.then(callback).catch((err=>{console.error("Uncaught error:",err)}));return}else{return promise}}once(event,options){if(event==="value"&&!this.isWildcardPath){return this.get(options)}return new Promise((resolve=>{const callback=snap=>{this.off(event,callback);resolve(snap)};this.on(event,callback)}))}push(value,onComplete){if(this.isWildcardPath){const error=new Error(`Cannot push to wildcard path "/${this.path}"`);if(typeof value==="undefined"||typeof onComplete==="function"){throw error}return Promise.reject(error)}const id=id_1.ID.generate();const ref=this.child(id);ref[_private].pushed=true;if(typeof value!=="undefined"){return ref.set(value,onComplete).then((()=>ref))}else{return ref}}async remove(){if(this.isWildcardPath){throw new Error(`Cannot remove wildcard path "/${this.path}". Use query().remove instead`)}if(this.parent===null){throw new Error("Cannot remove the root node")}return this.set(null)}async exists(){if(this.isWildcardPath){throw new Error(`Cannot check wildcard path "/${this.path}" existence`)}if(!this.db.isReady){await this.db.ready()}return this.db.api.exists(this.path)}get isWildcardPath(){return this.path.indexOf("*")>=0||this.path.indexOf("$")>=0}query(){return new DataReferenceQuery(this)}async count(){const info=await this.reflect("info",{child_count:true});return info.children.count}async reflect(type,args){if(this.isWildcardPath){throw new Error(`Cannot reflect on wildcard path "/${this.path}"`)}if(!this.db.isReady){await this.db.ready()}return this.db.api.reflect(this.path,type,args)}async export(write,options={format:"json",type_safe:true}){if(this.isWildcardPath){throw new Error(`Cannot export wildcard path "/${this.path}"`)}if(!this.db.isReady){await this.db.ready()}const writeFn=typeof write==="function"?write:write.write.bind(write);return this.db.api.export(this.path,writeFn,options)}async import(read,options={format:"json",suppress_events:false}){if(this.isWildcardPath){throw new Error(`Cannot import to wildcard path "/${this.path}"`)}if(!this.db.isReady){await this.db.ready()}return this.db.api.import(this.path,read,options)}proxy(options){const isOptionsArg=typeof options==="object"&&(typeof options.cursor!=="undefined"||typeof options.defaultValue!=="undefined");if(typeof options!=="undefined"&&!isOptionsArg){this.db.debug.warn("Warning: live data proxy is being initialized with a deprecated method signature. Use ref.proxy(options) instead of ref.proxy(defaultValue)");options={defaultValue:options}}return data_proxy_1.LiveDataProxy.create(this,options)}observe(options){if(options){throw new Error("observe does not support data retrieval options yet")}if(this.isWildcardPath){throw new Error(`Cannot observe wildcard path "/${this.path}"`)}const Observable=(0,optional_observable_1.getObservable)();return new Observable((observer=>{let cache,resolved=false;let promise=this.get(options).then((snap=>{resolved=true;cache=snap.val();observer.next(cache)}));const updateCache=snap=>{if(!resolved){promise=promise.then((()=>updateCache(snap)));return}const mutatedPath=snap.ref.path;if(mutatedPath===this.path){cache=snap.val();return observer.next(cache)}const trailKeys=path_info_1.PathInfo.getPathKeys(mutatedPath).slice(path_info_1.PathInfo.getPathKeys(this.path).length);let target=cache;while(trailKeys.length>1){const key=trailKeys.shift();if(!(key in target)){target[key]=typeof trailKeys[0]==="number"?[]:{}}target=target[key]}const prop=trailKeys.shift();const newValue=snap.val();if(newValue===null){target instanceof Array&&typeof prop==="number"?target.splice(prop,1):delete target[prop]}else{target[prop]=newValue}observer.next(cache)};this.on("mutated",updateCache);return()=>{this.off("mutated",updateCache)}}))}async forEach(callbackOrOptions,callback){let options;if(typeof callbackOrOptions==="function"){callback=callbackOrOptions}else{options=callbackOrOptions}if(typeof callback!=="function"){throw new TypeError("No callback function given")}const info=await this.reflect("children",{limit:0,skip:0});const summary={canceled:false,total:info.list.length,processed:0};for(let i=0;i<info.list.length;i++){const key=info.list[i].key;const snapshot=await this.child(key).get(options);summary.processed++;if(!snapshot.exists()){continue}const result=await callback(snapshot);if(result===false){summary.canceled=true;break}}return summary}async getMutations(cursorOrDate){const cursor=typeof cursorOrDate==="string"?cursorOrDate:undefined;const timestamp=cursorOrDate===null||typeof cursorOrDate==="undefined"?0:cursorOrDate instanceof Date?cursorOrDate.getTime():undefined;return this.db.api.getMutations({path:this.path,cursor:cursor,timestamp:timestamp})}async getChanges(cursorOrDate){const cursor=typeof cursorOrDate==="string"?cursorOrDate:undefined;const timestamp=cursorOrDate===null||typeof cursorOrDate==="undefined"?0:cursorOrDate instanceof Date?cursorOrDate.getTime():undefined;return this.db.api.getChanges({path:this.path,cursor:cursor,timestamp:timestamp})}}exports.DataReference=DataReference;class DataReferenceQuery{constructor(ref){this.ref=ref;this[_private]={filters:[],skip:0,take:0,order:[],events:{}}}filter(key,op,compare){if((op==="in"||op==="!in")&&(!(compare instanceof Array)||compare.length===0)){throw new Error(`${op} filter for ${key} must supply an Array compare argument containing at least 1 value`)}if((op==="between"||op==="!between")&&(!(compare instanceof Array)||compare.length!==2)){throw new Error(`${op} filter for ${key} must supply an Array compare argument containing 2 values`)}if((op==="matches"||op==="!matches")&&!(compare instanceof RegExp)){throw new Error(`${op} filter for ${key} must supply a RegExp compare argument`)}this[_private].filters.push({key:key,op:op,compare:compare});return this}where(key,op,compare){return this.filter(key,op,compare)}take(n){this[_private].take=n;return this}skip(n){this[_private].skip=n;return this}sort(key,ascending=true){if(!["string","number"].includes(typeof key)){throw"key must be a string or number"}this[_private].order.push({key:key,ascending:ascending});return this}order(key,ascending=true){return this.sort(key,ascending)}get(optionsOrCallback,callback){if(!this.ref.db.isReady){const promise=this.ref.db.ready().then((()=>this.get(optionsOrCallback,callback)));return typeof optionsOrCallback!=="function"&&typeof callback!=="function"?promise:undefined}callback=typeof optionsOrCallback==="function"?optionsOrCallback:typeof callback==="function"?callback:undefined;const options=new QueryDataRetrievalOptions(typeof optionsOrCallback==="object"?optionsOrCallback:{snapshots:true,cache_mode:"allow"});options.allow_cache=options.cache_mode!=="bypass";options.eventHandler=ev=>{if(!this[_private].events[ev.name]){return false}const listeners=this[_private].events[ev.name];if(typeof listeners!=="object"||listeners.length===0){return false}if(["add","change","remove"].includes(ev.name)){const eventData={name:ev.name,ref:new DataReference(this.ref.db,ev.path)};if(options.snapshots&&ev.name!=="remove"){const val=db.types.deserialize(ev.path,ev.value);eventData.snapshot=new data_snapshot_1.DataSnapshot(eventData.ref,val,false)}ev=eventData}listeners.forEach((callback=>{var _a,_b;try{callback(ev)}catch(err){this.ref.db.debug.error(`Error executing "${ev.name}" event handler of realtime query on path "${this.ref.path}": ${(_b=(_a=err===null||err===void 0?void 0:err.stack)!==null&&_a!==void 0?_a:err===null||err===void 0?void 0:err.message)!==null&&_b!==void 0?_b:err}`)}}))};options.monitor={add:false,change:false,remove:false};if(this[_private].events){if(this[_private].events["add"]&&this[_private].events["add"].length>0){options.monitor.add=true}if(this[_private].events["change"]&&this[_private].events["change"].length>0){options.monitor.change=true}if(this[_private].events["remove"]&&this[_private].events["remove"].length>0){options.monitor.remove=true}}this.stop();const db=this.ref.db;return db.api.query(this.ref.path,this[_private],options).catch((err=>{throw new Error(err)})).then((res=>{const{stop:stop}=res;let{results:results,context:context}=res;this.stop=async()=>{await stop()};if(!("results"in res&&"context"in res)){console.warn("Query results missing context. Update your acebase and/or acebase-client packages");results=res,context={}}if(options.snapshots){const snaps=results.map((result=>{const val=db.types.deserialize(result.path,result.val);return new data_snapshot_1.DataSnapshot(db.ref(result.path),val,false,undefined,context)}));return DataSnapshotsArray.from(snaps)}else{const refs=results.map((path=>db.ref(path)));return DataReferencesArray.from(refs)}})).then((results=>{callback&&callback(results);return results}))}async stop(){}getRefs(callback){return this.get({snapshots:false},callback)}find(){return this.get({snapshots:false})}async count(){const refs=await this.find();return refs.length}async exists(){const originalTake=this[_private].take;const p=this.take(1).find();this.take(originalTake);const refs=await p;return refs.length!==0}async remove(callback){const refs=await this.find();const parentUpdates=refs.reduce(((parents,ref)=>{const parent=parents[ref.parent.path];if(!parent){parents[ref.parent.path]=[ref]}else{parent.push(ref)}return parents}),{});const db=this.ref.db;const promises=Object.keys(parentUpdates).map((async parentPath=>{const updates=refs.reduce(((updates,ref)=>{updates[ref.key]=null;return updates}),{});const ref=db.ref(parentPath);try{await ref.update(updates);return{ref:ref,success:true}}catch(error){return{ref:ref,success:false,error:error}}}));const results=await Promise.all(promises);callback&&callback(results);return results}on(event,callback){if(!this[_private].events[event]){this[_private].events[event]=[]}this[_private].events[event].push(callback);return this}off(event,callback){if(typeof event==="undefined"){this[_private].events={};return this}if(!this[_private].events[event]){return this}if(typeof callback==="undefined"){delete this[_private].events[event];return this}const index=this[_private].events[event].indexOf(callback);if(!~index){return this}this[_private].events[event].splice(index,1);return this}async forEach(callbackOrOptions,callback){let options;if(typeof callbackOrOptions==="function"){callback=callbackOrOptions}else{options=callbackOrOptions}if(typeof callback!=="function"){throw new TypeError("No callback function given")}const refs=await this.find();const summary={canceled:false,total:refs.length,processed:0};for(let i=0;i<refs.length;i++){const ref=refs[i];const snapshot=await ref.get(options);summary.processed++;if(!snapshot.exists()){continue}const result=await callback(snapshot);if(result===false){summary.canceled=true;break}}return summary}}exports.DataReferenceQuery=DataReferenceQuery;class DataSnapshotsArray extends Array{static from(snaps){const arr=new DataSnapshotsArray(snaps.length);snaps.forEach(((snap,i)=>arr[i]=snap));return arr}getValues(){return this.map((snap=>snap.val()))}}exports.DataSnapshotsArray=DataSnapshotsArray;class DataReferencesArray extends Array{static from(refs){const arr=new DataReferencesArray(refs.length);refs.forEach(((ref,i)=>arr[i]=ref));return arr}getPaths(){return this.map((ref=>ref.path))}}exports.DataReferencesArray=DataReferencesArray},{"./data-proxy":38,"./data-snapshot":40,"./id":42,"./optional-observable":45,"./path-info":47,"./subscription":55}],40:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.MutationsDataSnapshot=exports.DataSnapshot=void 0;const path_info_1=require("./path-info");function getChild(snapshot,path,previous=false){if(!snapshot.exists()){return null}let child=previous?snapshot.previous():snapshot.val();if(typeof path==="number"){return child[path]}path_info_1.PathInfo.getPathKeys(path).every((key=>{child=child[key];return typeof child!=="undefined"}));return child||null}function getChildren(snapshot){if(!snapshot.exists()){return[]}const value=snapshot.val();if(value instanceof Array){return new Array(value.length).map(((v,i)=>i))}if(typeof value==="object"){return Object.keys(value)}return[]}class DataSnapshot{exists(){return false}constructor(ref,value,isRemoved=false,prevValue,context){this.ref=ref;this.val=()=>value;this.previous=()=>prevValue;this.exists=()=>{if(isRemoved){return false}return value!==null&&typeof value!=="undefined"};this.context=()=>context||{}}static for(ref,value){return new DataSnapshot(ref,value)}child(path){const val=getChild(this,path,false);const prev=getChild(this,path,true);return new DataSnapshot(this.ref.child(path),val,false,prev)}hasChild(path){return getChild(this,path)!==null}hasChildren(){return getChildren(this).length>0}numChildren(){return getChildren(this).length}forEach(callback){const value=this.val();const prev=this.previous();return getChildren(this).every((key=>{const snap=new DataSnapshot(this.ref.child(key),value[key],false,prev[key]);return callback(snap)}))}get key(){return this.ref.key}}exports.DataSnapshot=DataSnapshot;class MutationsDataSnapshot extends DataSnapshot{constructor(ref,mutations,context){super(ref,mutations,false,undefined,context);this.previous=()=>{throw new Error("Iterate values to get previous values for each mutation")};this.val=(warn=true)=>{if(warn){console.warn("Unless you know what you are doing, it is best not to use the value of a mutations snapshot directly. Use child methods and forEach to iterate the mutations instead")}return mutations}}forEach(callback){const mutations=this.val(false);return mutations.every((mutation=>{const ref=mutation.target.reduce(((ref,key)=>ref.child(key)),this.ref);const snap=new DataSnapshot(ref,mutation.val,false,mutation.prev);return callback(snap)}))}child(index){if(typeof index!=="number"){throw new Error("child index must be a number")}const mutation=this.val(false)[index];const ref=mutation.target.reduce(((ref,key)=>ref.child(key)),this.ref);return new DataSnapshot(ref,mutation.val,false,mutation.prev)}}exports.MutationsDataSnapshot=MutationsDataSnapshot},{"./path-info":47}],41:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.DebugLogger=void 0;const process_1=require("./process");const noop=()=>{};class DebugLogger{constructor(level="log",prefix=""){this.level=level;this.prefix=prefix;this.setLevel(level)}setLevel(level){const prefix=this.prefix?this.prefix+" %s":"";this.verbose=["verbose"].includes(level)?prefix?console.log.bind(console,prefix):console.log.bind(console):noop;this.log=["verbose","log"].includes(level)?prefix?console.log.bind(console,prefix):console.log.bind(console):noop;this.warn=["verbose","log","warn"].includes(level)?prefix?console.warn.bind(console,prefix):console.warn.bind(console):noop;this.error=["verbose","log","warn","error"].includes(level)?prefix?console.error.bind(console,prefix):console.error.bind(console):noop;this.write=text=>{const isRunKit=typeof process_1.default!=="undefined"&&process_1.default.env&&typeof process_1.default.env.RUNKIT_ENDPOINT_PATH==="string";if(text&&isRunKit){text.split("\n").forEach((line=>console.log(line)))}else{console.log(text)}}}}exports.DebugLogger=DebugLogger},{"./process":49}],42:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.ID=void 0;const cuid_1=require("./cuid");let timeBias=0;class ID{static set timeBias(bias){if(typeof bias!=="number"){return}timeBias=bias}static generate(){return(0,cuid_1.default)(timeBias).slice(1)}}exports.ID=ID},{"./cuid":36}],43:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.ObjectCollection=exports.PartialArray=exports.SimpleObservable=exports.SchemaDefinition=exports.Colorize=exports.ColorStyle=exports.SimpleEventEmitter=exports.SimpleCache=exports.ascii85=exports.PathInfo=exports.Utils=exports.TypeMappings=exports.Transport=exports.EventSubscription=exports.EventPublisher=exports.EventStream=exports.PathReference=exports.ID=exports.DebugLogger=exports.OrderedCollectionProxy=exports.proxyAccess=exports.MutationsDataSnapshot=exports.DataSnapshot=exports.DataReferencesArray=exports.DataSnapshotsArray=exports.QueryDataRetrievalOptions=exports.DataRetrievalOptions=exports.DataReferenceQuery=exports.DataReference=exports.Api=exports.AceBaseBaseSettings=exports.AceBaseBase=void 0;var acebase_base_1=require("./acebase-base");Object.defineProperty(exports,"AceBaseBase",{enumerable:true,get:function(){return acebase_base_1.AceBaseBase}});Object.defineProperty(exports,"AceBaseBaseSettings",{enumerable:true,get:function(){return acebase_base_1.AceBaseBaseSettings}});var api_1=require("./api");Object.defineProperty(exports,"Api",{enumerable:true,get:function(){return api_1.Api}});var data_reference_1=require("./data-reference");Object.defineProperty(exports,"DataReference",{enumerable:true,get:function(){return data_reference_1.DataReference}});Object.defineProperty(exports,"DataReferenceQuery",{enumerable:true,get:function(){return data_reference_1.DataReferenceQuery}});Object.defineProperty(exports,"DataRetrievalOptions",{enumerable:true,get:function(){return data_reference_1.DataRetrievalOptions}});Object.defineProperty(exports,"QueryDataRetrievalOptions",{enumerable:true,get:function(){return data_reference_1.QueryDataRetrievalOptions}});Object.defineProperty(exports,"DataSnapshotsArray",{enumerable:true,get:function(){return data_reference_1.DataSnapshotsArray}});Object.defineProperty(exports,"DataReferencesArray",{enumerable:true,get:function(){return data_reference_1.DataReferencesArray}});var data_snapshot_1=require("./data-snapshot");Object.defineProperty(exports,"DataSnapshot",{enumerable:true,get:function(){return data_snapshot_1.DataSnapshot}});Object.defineProperty(exports,"MutationsDataSnapshot",{enumerable:true,get:function(){return data_snapshot_1.MutationsDataSnapshot}});var data_proxy_1=require("./data-proxy");Object.defineProperty(exports,"proxyAccess",{enumerable:true,get:function(){return data_proxy_1.proxyAccess}});Object.defineProperty(exports,"OrderedCollectionProxy",{enumerable:true,get:function(){return data_proxy_1.OrderedCollectionProxy}});var debug_1=require("./debug");Object.defineProperty(exports,"DebugLogger",{enumerable:true,get:function(){return debug_1.DebugLogger}});var id_1=require("./id");Object.defineProperty(exports,"ID",{enumerable:true,get:function(){return id_1.ID}});var path_reference_1=require("./path-reference");Object.defineProperty(exports,"PathReference",{enumerable:true,get:function(){return path_reference_1.PathReference}});var subscription_1=require("./subscription");Object.defineProperty(exports,"EventStream",{enumerable:true,get:function(){return subscription_1.EventStream}});Object.defineProperty(exports,"EventPublisher",{enumerable:true,get:function(){return subscription_1.EventPublisher}});Object.defineProperty(exports,"EventSubscription",{enumerable:true,get:function(){return subscription_1.EventSubscription}});exports.Transport=require("./transport");var type_mappings_1=require("./type-mappings");Object.defineProperty(exports,"TypeMappings",{enumerable:true,get:function(){return type_mappings_1.TypeMappings}});exports.Utils=require("./utils");var path_info_1=require("./path-info");Object.defineProperty(exports,"PathInfo",{enumerable:true,get:function(){return path_info_1.PathInfo}});var ascii85_1=require("./ascii85");Object.defineProperty(exports,"ascii85",{enumerable:true,get:function(){return ascii85_1.ascii85}});var simple_cache_1=require("./simple-cache");Object.defineProperty(exports,"SimpleCache",{enumerable:true,get:function(){return simple_cache_1.SimpleCache}});var simple_event_emitter_1=require("./simple-event-emitter");Object.defineProperty(exports,"SimpleEventEmitter",{enumerable:true,get:function(){return simple_event_emitter_1.SimpleEventEmitter}});var simple_colors_1=require("./simple-colors");Object.defineProperty(exports,"ColorStyle",{enumerable:true,get:function(){return simple_colors_1.ColorStyle}});Object.defineProperty(exports,"Colorize",{enumerable:true,get:function(){return simple_colors_1.Colorize}});var schema_1=require("./schema");Object.defineProperty(exports,"SchemaDefinition",{enumerable:true,get:function(){return schema_1.SchemaDefinition}});var simple_observable_1=require("./simple-observable");Object.defineProperty(exports,"SimpleObservable",{enumerable:true,get:function(){return simple_observable_1.SimpleObservable}});var partial_array_1=require("./partial-array");Object.defineProperty(exports,"PartialArray",{enumerable:true,get:function(){return partial_array_1.PartialArray}});const object_collection_1=require("./object-collection");Object.defineProperty(exports,"ObjectCollection",{enumerable:true,get:function(){return object_collection_1.ObjectCollection}})},{"./acebase-base":32,"./api":33,"./ascii85":34,"./data-proxy":38,"./data-reference":39,"./data-snapshot":40,"./debug":41,"./id":42,"./object-collection":44,"./partial-array":46,"./path-info":47,"./path-reference":48,"./schema":50,"./simple-cache":51,"./simple-colors":52,"./simple-event-emitter":53,"./simple-observable":54,"./subscription":55,"./transport":56,"./type-mappings":57,"./utils":58}],44:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.ObjectCollection=void 0;const id_1=require("./id");class ObjectCollection{static from(array){const collection={};array.forEach((child=>{collection[id_1.ID.generate()]=child}));return collection}}exports.ObjectCollection=ObjectCollection},{"./id":42}],45:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.setObservable=exports.getObservable=void 0;const simple_observable_1=require("./simple-observable");const utils_1=require("./utils");let _shimRequested=false;let _observable;(async()=>{const global=(0,utils_1.getGlobalObject)();if(typeof global.Observable!=="undefined"){_observable=global.Observable;return}try{const{Observable:Observable}=await Promise.resolve().then((()=>require("rxjs")));_observable=Observable}catch(_a){_observable=simple_observable_1.SimpleObservable}})();function getObservable(){if(_observable===simple_observable_1.SimpleObservable&&!_shimRequested){console.warn("Using AceBase's simple Observable implementation because rxjs is not available. "+'Add it to your project with "npm install rxjs", add it to AceBase using db.setObservable(Observable), '+'or call db.setObservable("shim") to suppress this warning')}if(_observable){return _observable}throw new Error("RxJS Observable could not be loaded. ")}exports.getObservable=getObservable;function setObservable(Observable){if(Observable==="shim"){_observable=simple_observable_1.SimpleObservable;_shimRequested=true}else{_observable=Observable}}exports.setObservable=setObservable},{"./simple-observable":54,"./utils":58,rxjs:59}],46:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.PartialArray=void 0;class PartialArray{constructor(sparseArray){if(sparseArray instanceof Array){for(let i=0;i<sparseArray.length;i++){if(typeof sparseArray[i]!=="undefined"){this[i]=sparseArray[i]}}}else if(sparseArray){Object.assign(this,sparseArray)}}}exports.PartialArray=PartialArray},{}],47:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.PathInfo=void 0;function getPathKeys(path){path=path.replace(/\[/g,"/[").replace(/^\/+/,"").replace(/\/+$/,"");if(path.length===0){return[]}const keys=path.split("/");return keys.map((key=>key.startsWith("[")?parseInt(key.slice(1,-1)):key))}class PathInfo{static get(path){return new PathInfo(path)}static getChildPath(path,childKey){return PathInfo.get(path).child(childKey).path}static getPathKeys(path){return getPathKeys(path)}constructor(path){if(typeof path==="string"){this.keys=getPathKeys(path)}else if(path instanceof Array){this.keys=path}this.path=this.keys.reduce(((path,key,i)=>i===0?`${key}`:typeof key==="string"?`${path}/${key}`:`${path}[${key}]`),"")}get key(){return this.keys.length===0?null:this.keys.slice(-1)[0]}get parent(){if(this.keys.length==0){return null}const parentKeys=this.keys.slice(0,-1);return new PathInfo(parentKeys)}get parentPath(){return this.keys.length===0?null:this.parent.path}child(childKey){if(typeof childKey==="string"){if(childKey.length===0){throw new Error(`child key for path "${this.path}" cannot be empty`)}const keys=getPathKeys(childKey);keys.forEach((key=>{if(typeof key!=="string"){return}if(/[\x00-\x08\x0b\x0c\x0e-\x1f/[\]\\]/.test(key)){throw new Error(`Invalid child key "${key}" for path "${this.path}". Keys cannot contain control characters or any of the following characters: \\ / [ ]`)}if(key.length>128){throw new Error(`child key "${key}" for path "${this.path}" is too long. Max key length is 128`)}if(key.length===0){throw new Error(`child key for path "${this.path}" cannot be empty`)}}));childKey=keys}return new PathInfo(this.keys.concat(childKey))}childPath(childKey){return this.child(childKey).path}get pathKeys(){return this.keys}static extractVariables(varPath,fullPath){if(!varPath.includes("*")&&!varPath.includes("$")){return[]}const keys=getPathKeys(varPath);const pathKeys=getPathKeys(fullPath);let count=0;const variables={get length(){return count}};keys.forEach(((key,index)=>{const pathKey=pathKeys[index];if(key==="*"){variables[count++]=pathKey}else if(typeof key==="string"&&key[0]==="$"){variables[count++]=pathKey;variables[key]=pathKey;const varName=key.slice(1);if(typeof variables[varName]==="undefined"){variables[varName]=pathKey}}}));return variables}static fillVariables(varPath,fullPath){if(varPath.indexOf("*")<0&&varPath.indexOf("$")<0){return varPath}const keys=getPathKeys(varPath);const pathKeys=getPathKeys(fullPath);const merged=keys.map(((key,index)=>{if(key===pathKeys[index]||index>=pathKeys.length){return key}else if(typeof key==="string"&&(key==="*"||key[0]==="$")){return pathKeys[index]}else{throw new Error(`Path "${fullPath}" cannot be used to fill variables of path "${varPath}" because they do not match`)}}));let mergedPath="";merged.forEach((key=>{if(typeof key==="number"){mergedPath+=`[${key}]`}else{if(mergedPath.length>0){mergedPath+="/"}mergedPath+=key}}));return mergedPath}static fillVariables2(varPath,vars){if(typeof vars!=="object"||Object.keys(vars).length===0){return varPath}const pathKeys=getPathKeys(varPath);let n=0;const targetPath=pathKeys.reduce(((path,key)=>{if(typeof key==="string"&&(key==="*"||key.startsWith("$"))){return PathInfo.getChildPath(path,vars[n++])}else{return PathInfo.getChildPath(path,key)}}),"");return targetPath}equals(otherPath){const other=otherPath instanceof PathInfo?otherPath:new PathInfo(otherPath);if(this.path===other.path){return true}if(this.keys.length!==other.keys.length){return false}return this.keys.every(((key,index)=>{const otherKey=other.keys[index];return otherKey===key||typeof otherKey==="string"&&(otherKey==="*"||otherKey[0]==="$")||typeof key==="string"&&(key==="*"||key[0]==="$")}))}isAncestorOf(descendantPath){const descendant=descendantPath instanceof PathInfo?descendantPath:new PathInfo(descendantPath);if(descendant.path===""||this.path===descendant.path){return false}if(this.path===""){return true}if(this.keys.length>=descendant.keys.length){return false}return this.keys.every(((key,index)=>{const otherKey=descendant.keys[index];return otherKey===key||typeof otherKey==="string"&&(otherKey==="*"||otherKey[0]==="$")||typeof key==="string"&&(key==="*"||key[0]==="$")}))}isDescendantOf(ancestorPath){const ancestor=ancestorPath instanceof PathInfo?ancestorPath:new PathInfo(ancestorPath);if(this.path===""||this.path===ancestor.path){return false}if(ancestorPath===""){return true}if(ancestor.keys.length>=this.keys.length){return false}return ancestor.keys.every(((key,index)=>{const otherKey=this.keys[index];return otherKey===key||typeof otherKey==="string"&&(otherKey==="*"||otherKey[0]==="$")||typeof key==="string"&&(key==="*"||key[0]==="$")}))}isOnTrailOf(otherPath){const other=otherPath instanceof PathInfo?otherPath:new PathInfo(otherPath);if(this.path.length===0||other.path.length===0){return true}if(this.path===other.path){return true}return this.pathKeys.every(((key,index)=>{if(index>=other.keys.length){return true}const otherKey=other.keys[index];return otherKey===key||typeof otherKey==="string"&&(otherKey==="*"||otherKey[0]==="$")||typeof key==="string"&&(key==="*"||key[0]==="$")}))}isChildOf(otherPath){const other=otherPath instanceof PathInfo?otherPath:new PathInfo(otherPath);if(this.path===""){return false}return this.parent.equals(other)}isParentOf(otherPath){const other=otherPath instanceof PathInfo?otherPath:new PathInfo(otherPath);if(other.path===""){return false}return this.equals(other.parent)}}exports.PathInfo=PathInfo},{}],48:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.PathReference=void 0;class PathReference{constructor(path){this.path=path}}exports.PathReference=PathReference},{}],49:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.default={nextTick(fn){setTimeout(fn,0)}}},{}],50:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.SchemaDefinition=void 0;function parse(definition){let pos=0;function consumeSpaces(){let c;while(c=definition[pos],[" ","\r","\n","\t"].includes(c)){pos++}}function consumeCharacter(c){if(definition[pos]!==c){throw new Error(`Unexpected character at position ${pos}. Expected: '${c}', found '${definition[pos]}'`)}pos++}function readProperty(){consumeSpaces();const prop={name:"",optional:false,wildcard:false};let c;while(c=definition[pos],c==="_"||c==="$"||c>="a"&&c<="z"||c>="A"&&c<="Z"||prop.name.length>0&&c>="0"&&c<="9"||prop.name.length===0&&c==="*"){prop.name+=c;pos++}if(prop.name.length===0){throw new Error(`Property name expected at position ${pos}, found: ${definition.slice(pos,pos+10)}..`)}if(definition[pos]==="?"){prop.optional=true;pos++}if(prop.name==="*"||prop.name[0]==="$"){prop.optional=true;prop.wildcard=true}consumeSpaces();consumeCharacter(":");return prop}function readType(){consumeSpaces();let type={typeOf:"any"},c;let name="";while(c=definition[pos],c>="a"&&c<="z"||c>="A"&&c<="Z"){name+=c;pos++}if(name.length===0){if(definition[pos]==="*"){consumeCharacter("*");type.typeOf="any"}else if(["'",'"',"`"].includes(definition[pos])){type.typeOf="string";type.value="";const quote=definition[pos];consumeCharacter(quote);while(c=definition[pos],c&&c!==quote){type.value+=c;pos++}consumeCharacter(quote)}else if(definition[pos]>="0"&&definition[pos]<="9"){type.typeOf="number";let nr="";while(c=definition[pos],c==="."||c==="n"||c>="0"&&c<="9"){nr+=c;pos++}if(nr.endsWith("n")){type.value=BigInt(nr)}else if(nr.includes(".")){type.value=parseFloat(nr)}else{type.value=parseInt(nr)}}else if(definition[pos]==="{"){consumeCharacter("{");type.typeOf="object";type.instanceOf=Object;type.children=[];while(true){const prop=readProperty();const types=readTypes();type.children.push({name:prop.name,optional:prop.optional,wildcard:prop.wildcard,types:types});consumeSpaces();if(definition[pos]===";"||definition[pos]===","){consumeCharacter(definition[pos]);consumeSpaces()}if(definition[pos]==="}"){break}}consumeCharacter("}")}else if(definition[pos]==="/"){consumeCharacter("/");let pattern="",flags="";while(c=definition[pos],c!=="/"||pattern.endsWith("\\")){pattern+=c;pos++}consumeCharacter("/");while(c=definition[pos],["g","i","m","s","u","y","d"].includes(c)){flags+=c;pos++}type.typeOf="string";type.matches=new RegExp(pattern,flags)}else{throw new Error(`Expected a type definition at position ${pos}, found character '${definition[pos]}'`)}}else if(["string","number","boolean","bigint","undefined","String","Number","Boolean","BigInt"].includes(name)){type.typeOf=name.toLowerCase()}else if(name==="Object"||name==="object"){type.typeOf="object";type.instanceOf=Object}else if(name==="Date"){type.typeOf="object";type.instanceOf=Date}else if(name==="Binary"||name==="binary"){type.typeOf="object";type.instanceOf=ArrayBuffer}else if(name==="any"){type.typeOf="any"}else if(name==="null"){type.typeOf="object";type.value=null}else if(name==="Array"){consumeCharacter("<");type.typeOf="object";type.instanceOf=Array;type.genericTypes=readTypes();consumeCharacter(">")}else if(["true","false"].includes(name)){type.typeOf="boolean";type.value=name==="true"}else{throw new Error(`Unknown type at position ${pos}: "${type}"`)}consumeSpaces();while(definition[pos]==="["){consumeCharacter("[");consumeCharacter("]");type={typeOf:"object",instanceOf:Array,genericTypes:[type]}}return type}function readTypes(){consumeSpaces();const types=[readType()];while(definition[pos]==="|"){consumeCharacter("|");types.push(readType());consumeSpaces()}return types}return readType()}function checkObject(path,properties,obj,partial){const invalidProperties=properties.find((prop=>prop.name==="*"||prop.name[0]==="$"))?[]:Object.keys(obj).filter((key=>![null,undefined].includes(obj[key])&&!properties.find((prop=>prop.name===key))));if(invalidProperties.length>0){return{ok:false,reason:`Object at path "${path}" cannot have propert${invalidProperties.length===1?"y":"ies"} ${invalidProperties.map((p=>`"${p}"`)).join(", ")}`}}function checkProperty(property){const hasValue=![null,undefined].includes(obj[property.name]);if(!property.optional&&(partial?obj[property.name]===null:!hasValue)){return{ok:false,reason:`Property at path "${path}/${property.name}" is not optional`}}if(hasValue&&property.types.length===1){return checkType(`${path}/${property.name}`,property.types[0],obj[property.name],false)}if(hasValue&&!property.types.some((type=>checkType(`${path}/${property.name}`,type,obj[property.name],false).ok))){return{ok:false,reason:`Property at path "${path}/${property.name}" does not match any of ${property.types.length} allowed types`}}return{ok:true}}const namedProperties=properties.filter((prop=>!prop.wildcard));const failedProperty=namedProperties.find((prop=>!checkProperty(prop).ok));if(failedProperty){const reason=checkProperty(failedProperty).reason;return{ok:false,reason:reason}}const wildcardProperty=properties.find((prop=>prop.wildcard));if(!wildcardProperty){return{ok:true}}const wildcardChildKeys=Object.keys(obj).filter((key=>!namedProperties.find((prop=>prop.name===key))));let result={ok:true};for(let i=0;i<wildcardChildKeys.length&&result.ok;i++){const childKey=wildcardChildKeys[i];result=checkProperty({name:childKey,types:wildcardProperty.types,optional:true,wildcard:true})}return result}function checkType(path,type,value,partial,trailKeys){const ok={ok:true};if(type.typeOf==="any"){return ok}if(trailKeys instanceof Array&&trailKeys.length>0){if(type.typeOf!=="object"){return{ok:false,reason:`path "${path}" must be typeof ${type.typeOf}`}}if(!type.children){return ok}const childKey=trailKeys[0];let property=type.children.find((prop=>prop.name===childKey));if(!property){property=type.children.find((prop=>prop.name==="*"||prop.name[0]==="$"))}if(!property){return{ok:false,reason:`Object at path "${path}" cannot have property "${childKey}"`}}if(property.optional&&value===null&&trailKeys.length===1){return ok}let result;property.types.some((type=>{const childPath=typeof childKey==="number"?`${path}[${childKey}]`:`${path}/${childKey}`;result=checkType(childPath,type,value,partial,trailKeys.slice(1));return result.ok}));return result}if(value===null){return ok}if(type.instanceOf===Object&&(typeof value!=="object"||value instanceof Array||value instanceof Date)){return{ok:false,reason:`path "${path}" must be an object collection`}}if(type.instanceOf&&(typeof value!=="object"||value.constructor!==type.instanceOf)){return{ok:false,reason:`path "${path}" must be an instance of ${type.instanceOf.name}`}}if("value"in type&&value!==type.value){return{ok:false,reason:`path "${path}" must be value: ${type.value}`}}if(typeof value!==type.typeOf){return{ok:false,reason:`path "${path}" must be typeof ${type.typeOf}`}}if(type.instanceOf===Array&&type.genericTypes&&!value.every((v=>type.genericTypes.some((t=>checkType(path,t,v,false).ok))))){return{ok:false,reason:`every array value of path "${path}" must match one of the specified types`}}if(type.typeOf==="object"&&type.children){return checkObject(path,type.children,value,partial)}if(type.matches&&!type.matches.test(value)){return{ok:false,reason:`path "${path}" must match regular expression /${type.matches.source}/${type.matches.flags}`}}return ok}function getConstructorType(val){switch(val){case String:return"string";case Number:return"number";case Boolean:return"boolean";case Date:return"Date";case BigInt:return"bigint";case Array:throw new Error("Schema error: Array cannot be used without a type. Use string[] or Array<string> instead");default:throw new Error(`Schema error: unknown type used: ${val.name}`)}}class SchemaDefinition{constructor(definition,handling={warnOnly:false}){this.handling=handling;this.source=definition;if(typeof definition==="object"){const toTS=obj=>"{"+Object.keys(obj).map((key=>{let val=obj[key];if(val===undefined){val="undefined"}else if(val instanceof RegExp){val=`/${val.source}/${val.flags}`}else if(typeof val==="object"){val=toTS(val)}else if(typeof val==="function"){val=getConstructorType(val)}else if(!["string","number","boolean","bigint"].includes(typeof val)){throw new Error(`Type definition for key "${key}" must be a string, number, boolean, bigint, object, regular expression, or one of these classes: String, Number, Boolean, Date, BigInt`)}return`${key}:${val}`})).join(",")+"}";this.text=toTS(definition)}else if(typeof definition==="string"){this.text=definition}else{throw new Error("Type definiton must be a string or an object")}this.type=parse(this.text)}check(path,value,partial,trailKeys){const result=checkType(path,this.type,value,partial,trailKeys);if(!result.ok&&this.handling.warnOnly){result.warning=`${partial?"Partial schema":"Schema"} check on path "${path}"${trailKeys?` for child "${trailKeys.join("/")}"`:""} failed: ${result.reason}`;result.ok=true;this.handling.warnCallback(result.warning)}return result}}exports.SchemaDefinition=SchemaDefinition},{}],51:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.SimpleCache=void 0;const utils_1=require("./utils");const calculateExpiryTime=expirySeconds=>expirySeconds>0?Date.now()+expirySeconds*1e3:Infinity;class SimpleCache{get size(){return this.cache.size}constructor(options){var _a;this.enabled=true;if(typeof options==="number"){options={expirySeconds:options}}options.cloneValues=options.cloneValues!==false;if(typeof options.expirySeconds!=="number"&&typeof options.maxEntries!=="number"){throw new Error("Either expirySeconds or maxEntries must be specified")}this.options=options;this.cache=new Map;const interval=setInterval((()=>{this.cleanUp()}),60*1e3);(_a=interval.unref)===null||_a===void 0?void 0:_a.call(interval)}has(key){if(!this.enabled){return false}return this.cache.has(key)}get(key){if(!this.enabled){return null}const entry=this.cache.get(key);if(!entry){return null}entry.expires=calculateExpiryTime(this.options.expirySeconds);entry.accessed=Date.now();return this.options.cloneValues?(0,utils_1.cloneObject)(entry.value):entry.value}set(key,value){if(this.options.maxEntries>0&&this.cache.size>=this.options.maxEntries&&!this.cache.has(key)){let oldest=null;const now=Date.now();for(const[key,entry]of this.cache.entries()){if(entry.expires<=now){this.cache.delete(key);oldest=null;break}if(!oldest||entry.accessed<oldest.accessed){oldest={key:key,accessed:entry.accessed}}}if(oldest!==null){this.cache.delete(oldest.key)}}this.cache.set(key,{value:this.options.cloneValues?(0,utils_1.cloneObject)(value):value,added:Date.now(),accessed:Date.now(),expires:calculateExpiryTime(this.options.expirySeconds)})}remove(key){this.cache.delete(key)}cleanUp(){const now=Date.now();this.cache.forEach(((entry,key)=>{if(entry.expires<=now){this.cache.delete(key)}}))}}exports.SimpleCache=SimpleCache},{"./utils":58}],52:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.Colorize=exports.SetColorsEnabled=exports.ColorsSupported=exports.ColorStyle=void 0;const process_1=require("./process");const FontCode={bold:1,dim:2,italic:3,underline:4,inverse:7,hidden:8,strikethrough:94};const ColorCode={black:30,red:31,green:32,yellow:33,blue:34,magenta:35,cyan:36,white:37,grey:90,brightRed:91};const BgColorCode={bgBlack:40,bgRed:41,bgGreen:42,bgYellow:43,bgBlue:44,bgMagenta:45,bgCyan:46,bgWhite:47,bgGrey:100,bgBrightRed:101};const ResetCode={all:0,color:39,background:49,bold:22,dim:22,italic:23,underline:24,inverse:27,hidden:28,strikethrough:29};var ColorStyle;(function(ColorStyle){ColorStyle["reset"]="reset";ColorStyle["bold"]="bold";ColorStyle["dim"]="dim";ColorStyle["italic"]="italic";ColorStyle["underline"]="underline";ColorStyle["inverse"]="inverse";ColorStyle["hidden"]="hidden";ColorStyle["strikethrough"]="strikethrough";ColorStyle["black"]="black";ColorStyle["red"]="red";ColorStyle["green"]="green";ColorStyle["yellow"]="yellow";ColorStyle["blue"]="blue";ColorStyle["magenta"]="magenta";ColorStyle["cyan"]="cyan";ColorStyle["grey"]="grey";ColorStyle["bgBlack"]="bgBlack";ColorStyle["bgRed"]="bgRed";ColorStyle["bgGreen"]="bgGreen";ColorStyle["bgYellow"]="bgYellow";ColorStyle["bgBlue"]="bgBlue";ColorStyle["bgMagenta"]="bgMagenta";ColorStyle["bgCyan"]="bgCyan";ColorStyle["bgWhite"]="bgWhite";ColorStyle["bgGrey"]="bgGrey"})(ColorStyle=exports.ColorStyle||(exports.ColorStyle={}));function ColorsSupported(){if(typeof process_1.default==="undefined"||!process_1.default.stdout||!process_1.default.env||!process_1.default.platform||process_1.default.platform==="browser"){return false}if(process_1.default.platform==="win32"){return true}const env=process_1.default.env;if(env.COLORTERM){return true}if(env.TERM==="dumb"){return false}if(env.CI||env.TEAMCITY_VERSION){return!!env.TRAVIS}if(["iTerm.app","HyperTerm","Hyper","MacTerm","Apple_Terminal","vscode"].includes(env.TERM_PROGRAM)){return true}if(/^xterm-256|^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(env.TERM)){return true}return false}exports.ColorsSupported=ColorsSupported;let _enabled=ColorsSupported();function SetColorsEnabled(enabled){_enabled=ColorsSupported()&&enabled}exports.SetColorsEnabled=SetColorsEnabled;function Colorize(str,style){if(!_enabled){return str}const openCodes=[],closeCodes=[];const addStyle=style=>{if(style===ColorStyle.reset){openCodes.push(ResetCode.all)}else if(style in FontCode){openCodes.push(FontCode[style]);closeCodes.push(ResetCode[style])}else if(style in ColorCode){openCodes.push(ColorCode[style]);closeCodes.push(ResetCode.color)}else if(style in BgColorCode){openCodes.push(BgColorCode[style]);closeCodes.push(ResetCode.background)}};if(style instanceof Array){style.forEach(addStyle)}else{addStyle(style)}const open=openCodes.map((code=>"["+code+"m")).join("");const close=closeCodes.map((code=>"["+code+"m")).join("");return str.split("\n").map((line=>open+line+close)).join("\n")}exports.Colorize=Colorize;String.prototype.colorize=function(style){return Colorize(this,style)}},{"./process":49}],53:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.SimpleEventEmitter=void 0;function runCallback(callback,data){try{callback(data)}catch(err){console.error("Error in subscription callback",err)}}const _subscriptions=Symbol("subscriptions");const _oneTimeEvents=Symbol("oneTimeEvents");class SimpleEventEmitter{constructor(){this[_subscriptions]=[];this[_oneTimeEvents]=new Map}on(event,callback){if(this[_oneTimeEvents].has(event)){return runCallback(callback,this[_oneTimeEvents].get(event))}this[_subscriptions].push({event:event,callback:callback,once:false});return this}off(event,callback){this[_subscriptions]=this[_subscriptions].filter((s=>s.event!==event||callback&&s.callback!==callback));return this}once(event,callback){return new Promise((resolve=>{const ourCallback=data=>{resolve(data);callback===null||callback===void 0?void 0:callback(data)};if(this[_oneTimeEvents].has(event)){runCallback(ourCallback,this[_oneTimeEvents].get(event))}else{this[_subscriptions].push({event:event,callback:ourCallback,once:true})}}))}emit(event,data){if(this[_oneTimeEvents].has(event)){throw new Error(`Event "${event}" was supposed to be emitted only once`)}for(let i=0;i<this[_subscriptions].length;i++){const s=this[_subscriptions][i];if(s.event!==event){continue}runCallback(s.callback,data);if(s.once){this[_subscriptions].splice(i,1);i--}}return this}emitOnce(event,data){if(this[_oneTimeEvents].has(event)){throw new Error(`Event "${event}" was supposed to be emitted only once`)}this.emit(event,data);this[_oneTimeEvents].set(event,data);this.off(event);return this}pipe(event,eventEmitter){this.on(event,(data=>{eventEmitter.emit(event,data)}))}pipeOnce(event,eventEmitter){this.once(event,(data=>{eventEmitter.emitOnce(event,data)}))}}exports.SimpleEventEmitter=SimpleEventEmitter},{}],54:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.SimpleObservable=void 0;class SimpleObservable{constructor(create){this._active=false;this._subscribers=[];this._create=create}subscribe(subscriber){if(!this._active){const next=value=>{this._subscribers.forEach((s=>{try{s(value)}catch(err){console.error("Error in subscriber callback:",err)}}))};const observer={next:next};this._cleanup=this._create(observer);this._active=true}this._subscribers.push(subscriber);const unsubscribe=()=>{this._subscribers.splice(this._subscribers.indexOf(subscriber),1);if(this._subscribers.length===0){this._active=false;this._cleanup()}};const subscription={unsubscribe:unsubscribe};return subscription}}exports.SimpleObservable=SimpleObservable},{}],55:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.EventStream=exports.EventPublisher=exports.EventSubscription=void 0;class EventSubscription{constructor(stop){this.stop=stop;this._internal={state:"init",activatePromises:[]}}activated(callback){if(callback){this._internal.activatePromises.push({callback:callback});if(this._internal.state==="active"){callback(true)}else if(this._internal.state==="canceled"){callback(false,this._internal.cancelReason)}}return new Promise(((resolve,reject)=>{if(this._internal.state==="active"){return resolve()}else if(this._internal.state==="canceled"&&!callback){return reject(new Error(this._internal.cancelReason))}const noop=()=>{};this._internal.activatePromises.push({resolve:resolve,reject:callback?noop:reject})}))}_setActivationState(activated,cancelReason){this._internal.cancelReason=cancelReason;this._internal.state=activated?"active":"canceled";while(this._internal.activatePromises.length>0){const p=this._internal.activatePromises.shift();if(activated){p.callback&&p.callback(true);p.resolve&&p.resolve()}else{p.callback&&p.callback(false,cancelReason);p.reject&&p.reject(cancelReason)}}}}exports.EventSubscription=EventSubscription;class EventPublisher{constructor(publish,start,cancel){this.publish=publish;this.start=start;this.cancel=cancel}}exports.EventPublisher=EventPublisher;class EventStream{constructor(eventPublisherCallback){const subscribers=[];let noMoreSubscribersCallback;let activationState;const STATE_STOPPED="stopped (no more subscribers)";this.subscribe=(callback,activationCallback)=>{if(typeof callback!=="function"){throw new TypeError("callback must be a function")}else if(activationState===STATE_STOPPED){throw new Error("stream can't be used anymore because all subscribers were stopped")}const sub={callback:callback,activationCallback:function(activated,cancelReason){activationCallback===null||activationCallback===void 0?void 0:activationCallback(activated,cancelReason);this.subscription._setActivationState(activated,cancelReason)},subscription:new EventSubscription((function stop(){subscribers.splice(subscribers.indexOf(this),1);return checkActiveSubscribers()}))};subscribers.push(sub);if(typeof activationState!=="undefined"){if(activationState===true){activationCallback===null||activationCallback===void 0?void 0:activationCallback(true);sub.subscription._setActivationState(true)}else if(typeof activationState==="string"){activationCallback===null||activationCallback===void 0?void 0:activationCallback(false,activationState);sub.subscription._setActivationState(false,activationState)}}return sub.subscription};const checkActiveSubscribers=()=>{let ret;if(subscribers.length===0){ret=noMoreSubscribersCallback===null||noMoreSubscribersCallback===void 0?void 0:noMoreSubscribersCallback();activationState=STATE_STOPPED}return Promise.resolve(ret)};this.unsubscribe=callback=>{const remove=callback?subscribers.filter((sub=>sub.callback===callback)):subscribers;remove.forEach((sub=>{const i=subscribers.indexOf(sub);subscribers.splice(i,1)}));checkActiveSubscribers()};this.stop=()=>{subscribers.splice(0);checkActiveSubscribers()};const publish=val=>{subscribers.forEach((sub=>{try{sub.callback(val)}catch(err){console.error(`Error running subscriber callback: ${err.message}`)}}));if(subscribers.length===0){checkActiveSubscribers()}return subscribers.length>0};const start=allSubscriptionsStoppedCallback=>{activationState=true;noMoreSubscribersCallback=allSubscriptionsStoppedCallback;subscribers.forEach((sub=>{var _a;(_a=sub.activationCallback)===null||_a===void 0?void 0:_a.call(sub,true)}))};const cancel=reason=>{activationState=reason;subscribers.forEach((sub=>{var _a;(_a=sub.activationCallback)===null||_a===void 0?void 0:_a.call(sub,false,reason||new Error("unknown reason"))}));subscribers.splice(0)};const publisher=new EventPublisher(publish,start,cancel);eventPublisherCallback(publisher)}}exports.EventStream=EventStream},{}],56:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.deserialize2=exports.serialize2=exports.serialize=exports.detectSerializeVersion=exports.deserialize=void 0;const path_reference_1=require("./path-reference");const utils_1=require("./utils");const ascii85_1=require("./ascii85");const path_info_1=require("./path-info");const partial_array_1=require("./partial-array");const deserialize=data=>{if(data.map===null||typeof data.map==="undefined"){if(typeof data.val==="undefined"){throw new Error("serialized value must have a val property")}return data.val}const deserializeValue=(type,val)=>{if(type==="date"){return new Date(val)}else if(type==="binary"){return ascii85_1.ascii85.decode(val)}else if(type==="reference"){return new path_reference_1.PathReference(val)}else if(type==="regexp"){return new RegExp(val.pattern,val.flags)}else if(type==="array"){return new partial_array_1.PartialArray(val)}else if(type==="bigint"){return BigInt(val)}return val};if(typeof data.map==="string"){return deserializeValue(data.map,data.val)}Object.keys(data.map).forEach((path=>{const type=data.map[path];const keys=path_info_1.PathInfo.getPathKeys(path);let parent=data;let key="val";let val=data.val;keys.forEach((k=>{key=k;parent=val;val=val[key]}));parent[key]=deserializeValue(type,val)}));return data.val};exports.deserialize=deserialize;const detectSerializeVersion=data=>{if(typeof data!=="object"||data===null){return 2}if("map"in data&&"val"in data){return 1}else if("val"in data){if(Object.keys(data).length>1){return 2}return 1}return 2};exports.detectSerializeVersion=detectSerializeVersion;const serialize=obj=>{var _a;if(obj===null||typeof obj!=="object"||obj instanceof Date||obj instanceof ArrayBuffer||obj instanceof path_reference_1.PathReference||obj instanceof RegExp){const ser=(0,exports.serialize)({value:obj});return{map:(_a=ser.map)===null||_a===void 0?void 0:_a.value,val:ser.val.value}}obj=(0,utils_1.cloneObject)(obj);const process=(obj,mappings,prefix)=>{if(obj instanceof partial_array_1.PartialArray){mappings[prefix]="array"}Object.keys(obj).forEach((key=>{const val=obj[key];const path=prefix.length===0?key:`${prefix}/${key}`;if(typeof val==="bigint"){obj[key]=val.toString();mappings[path]="bigint"}else if(val instanceof Date){obj[key]=val.toISOString();mappings[path]="date"}else if(val instanceof ArrayBuffer){obj[key]=ascii85_1.ascii85.encode(val);mappings[path]="binary"}else if(val instanceof path_reference_1.PathReference){obj[key]=val.path;mappings[path]="reference"}else if(val instanceof RegExp){obj[key]={pattern:val.source,flags:val.flags};mappings[path]="regexp"}else if(typeof val==="object"&&val!==null){process(val,mappings,path)}}))};const mappings={};process(obj,mappings,"");const serialized={val:obj};if(Object.keys(mappings).length>0){serialized.map=mappings}return serialized};exports.serialize=serialize;const serialize2=obj=>{const getSerializedValue=val=>{if(typeof val==="bigint"){return{".type":"bigint",".val":val.toString()}}else if(val instanceof Date){return{".type":"date",".val":val.toISOString()}}else if(val instanceof ArrayBuffer){return{".type":"binary",".val":ascii85_1.ascii85.encode(val)}}else if(val instanceof path_reference_1.PathReference){return{".type":"reference",".val":val.path}}else if(val instanceof RegExp){return{".type":"regexp",".val":`/${val.source}/${val.flags}`}}else if(typeof val==="object"&&val!==null){if(val instanceof Array){const copy=[];for(let i=0;i<val.length;i++){copy[i]=getSerializedValue(val[i])}return copy}else{const copy={};if(val instanceof partial_array_1.PartialArray){copy[".type"]="array"}for(const prop in val){copy[prop]=getSerializedValue(val[prop])}return copy}}else{return val}};const serialized=getSerializedValue(obj);if(serialized!==null&&typeof serialized==="object"&&"val"in serialized&&Object.keys(serialized).length===1){serialized[".version"]=2}return serialized};exports.serialize2=serialize2;const deserialize2=data=>{if(typeof data!=="object"||data===null){return data}if(typeof data[".type"]==="undefined"){if(data instanceof Array){const copy=[];const arr=data;for(let i=0;i<arr.length;i++){copy.push((0,exports.deserialize2)(arr[i]))}return copy}else{const copy={};const obj=data;for(const prop in obj){copy[prop]=(0,exports.deserialize2)(obj[prop])}return copy}}else if(typeof data[".type"]==="string"){const dataType=data[".type"].toLowerCase();if(dataType==="bigint"){const val=data[".val"];return BigInt(val)}else if(dataType==="array"){const arr=data;const copy={};for(const index in arr){copy[index]=(0,exports.deserialize2)(arr[index])}delete copy[".type"];return new partial_array_1.PartialArray(copy)}else if(dataType==="date"){const val=data[".val"];return new Date(val)}else if(dataType==="binary"){const val=data[".val"];return ascii85_1.ascii85.decode(val)}else if(dataType==="reference"){const val=data[".val"];return new path_reference_1.PathReference(val)}else if(dataType==="regexp"){const val=data[".val"];if(typeof val==="string"){const match=/^\/(.*)\/([a-z]+)$/.exec(val);return new RegExp(match[1],match[2])}return new RegExp(val.pattern,val.flags)}}throw new Error(`Unknown data type "${data[".type"]}" in serialized value`)};exports.deserialize2=deserialize2},{"./ascii85":34,"./partial-array":46,"./path-info":47,"./path-reference":48,"./utils":58}],57:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.TypeMappings=void 0;const utils_1=require("./utils");const path_info_1=require("./path-info");const data_reference_1=require("./data-reference");const data_snapshot_1=require("./data-snapshot");function get(mappings,path){path=path.replace(/^\/|\/$/g,"");const keys=path_info_1.PathInfo.getPathKeys(path);const mappedPath=Object.keys(mappings).find((mpath=>{const mkeys=path_info_1.PathInfo.getPathKeys(mpath);if(mkeys.length!==keys.length){return false}return mkeys.every(((mkey,index)=>{if(mkey==="*"||typeof mkey==="string"&&mkey[0]==="$"){return true}return mkey===keys[index]}))}));const mapping=mappings[mappedPath];return mapping}function map(mappings,path){const targetPath=path_info_1.PathInfo.get(path).parentPath;if(targetPath===null){return}return get(mappings,targetPath)}function mapDeep(mappings,entryPath){entryPath=entryPath.replace(/^\/|\/$/g,"");const pathInfo=path_info_1.PathInfo.get(entryPath);const startPath=pathInfo.parentPath;const keys=startPath?path_info_1.PathInfo.getPathKeys(startPath):[];const matches=Object.keys(mappings).reduce(((m,mpath)=>{const mkeys=path_info_1.PathInfo.getPathKeys(mpath);if(mkeys.length<keys.length){return m}let isMatch=true;if(keys.length===0&&startPath!==null){isMatch=mkeys.length===1&&(mkeys[0]==="*"||typeof mkeys[0]==="string"&&mkeys[0][0]==="$")}else{mkeys.every(((mkey,index)=>{if(index>=keys.length){return false}else if(mkey==="*"||typeof mkey==="string"&&mkey[0]==="$"||mkey===keys[index]){return true}else{isMatch=false;return false}}))}if(isMatch){const mapping=mappings[mpath];m.push({path:mpath,type:mapping})}return m}),[]);return matches}function process(db,mappings,path,obj,action){if(obj===null||typeof obj!=="object"){return obj}const keys=path_info_1.PathInfo.getPathKeys(path);const m=mapDeep(mappings,path);const changes=[];m.sort(((a,b)=>path_info_1.PathInfo.getPathKeys(a.path).length>path_info_1.PathInfo.getPathKeys(b.path).length?-1:1));m.forEach((mapping=>{const mkeys=path_info_1.PathInfo.getPathKeys(mapping.path);mkeys.push("*");const mTrailKeys=mkeys.slice(keys.length);if(mTrailKeys.length===0){const vars=path_info_1.PathInfo.extractVariables(mapping.path,path);const ref=new data_reference_1.DataReference(db,path,vars);if(action==="serialize"){obj=mapping.type.serialize(obj,ref)}else if(action==="deserialize"){const snap=new data_snapshot_1.DataSnapshot(ref,obj);obj=mapping.type.deserialize(snap)}return}const process=(parentPath,parent,keys)=>{if(obj===null||typeof obj!=="object"){return obj}const key=keys[0];let children=[];if(key==="*"||typeof key==="string"&&key[0]==="$"){if(parent instanceof Array){children=parent.map(((val,index)=>({key:index,val:val})))}else{children=Object.keys(parent).map((k=>({key:k,val:parent[k]})))}}else{const child=parent[key];if(typeof child==="object"){children.push({key:key,val:child})}}children.forEach((child=>{const childPath=path_info_1.PathInfo.getChildPath(parentPath,child.key);const vars=path_info_1.PathInfo.extractVariables(mapping.path,childPath);const ref=new data_reference_1.DataReference(db,childPath,vars);if(keys.length===1){if(action==="serialize"){changes.push({parent:parent,key:child.key,original:parent[child.key]});parent[child.key]=mapping.type.serialize(child.val,ref)}else if(action==="deserialize"){const snap=new data_snapshot_1.DataSnapshot(ref,child.val);parent[child.key]=mapping.type.deserialize(snap)}}else{process(childPath,child.val,keys.slice(1))}}))};process(path,obj,mTrailKeys)}));if(action==="serialize"){obj=(0,utils_1.cloneObject)(obj);if(changes.length>0){changes.forEach((change=>{change.parent[change.key]=change.original}))}}return obj}const _mappings=Symbol("mappings");class TypeMappings{constructor(db){this.db=db;this[_mappings]={}}get mappings(){return this[_mappings]}map(path){return map(this[_mappings],path)}bind(path,type,options={}){if(typeof path!=="string"){throw new TypeError("path must be a string")}if(typeof type!=="function"){throw new TypeError("constructor must be a function")}if(typeof options.serializer==="undefined"){}else if(typeof options.serializer==="string"){if(typeof type.prototype[options.serializer]==="function"){options.serializer=type.prototype[options.serializer]}else{throw new TypeError(`${type.name}.prototype.${options.serializer} is not a function, cannot use it as serializer`)}}else if(typeof options.serializer!=="function"){throw new TypeError(`serializer for class ${type.name} must be a function, or the name of a prototype method`)}if(typeof options.creator==="undefined"){if(typeof type.create==="function"){options.creator=type.create}}else if(typeof options.creator==="string"){if(typeof type[options.creator]==="function"){options.creator=type[options.creator]}else{throw new TypeError(`${type.name}.${options.creator} is not a function, cannot use it as creator`)}}else if(typeof options.creator!=="function"){throw new TypeError(`creator for class ${type.name} must be a function, or the name of a static method`)}path=path.replace(/^\/|\/$/g,"");this[_mappings][path]={db:this.db,type:type,creator:options.creator,serializer:options.serializer,deserialize(snap){let obj;if(this.creator){obj=this.creator.call(this.type,snap)}else{obj=new this.type(snap)}return obj},serialize(obj,ref){if(this.serializer){obj=this.serializer.call(obj,ref,obj)}else if(obj&&typeof obj.serialize==="function"){obj=obj.serialize(ref,obj)}return obj}}}serialize(path,obj){return process(this.db,this[_mappings],path,obj,"serialize")}deserialize(path,obj){return process(this.db,this[_mappings],path,obj,"deserialize")}}exports.TypeMappings=TypeMappings},{"./data-reference":39,"./data-snapshot":40,"./path-info":47,"./utils":58}],58:[function(require,module,exports){(function(global,Buffer){(function(){"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.getGlobalObject=exports.defer=exports.getChildValues=exports.getMutations=exports.compareValues=exports.ObjectDifferences=exports.valuesAreEqual=exports.cloneObject=exports.concatTypedArrays=exports.decodeString=exports.encodeString=exports.bytesToBigint=exports.bigintToBytes=exports.bytesToNumber=exports.numberToBytes=void 0;const path_reference_1=require("./path-reference");const process_1=require("./process");const partial_array_1=require("./partial-array");function numberToBytes(number){const bytes=new Uint8Array(8);const view=new DataView(bytes.buffer);view.setFloat64(0,number);return new Array(...bytes)}exports.numberToBytes=numberToBytes;function bytesToNumber(bytes){const length=Array.isArray(bytes)?bytes.length:bytes.byteLength;if(length!==8){throw new TypeError("must be 8 bytes")}const bin=new Uint8Array(bytes);const view=new DataView(bin.buffer);const nr=view.getFloat64(0);return nr}exports.bytesToNumber=bytesToNumber;const hasBigIntSupport=(()=>{try{return typeof BigInt(0)==="bigint"}catch(err){return false}})();const noBigIntError="BigInt is not supported on this platform";const bigIntFunctions={bigintToBytes(number){throw new Error(noBigIntError)},bytesToBigint(bytes){throw new Error(noBigIntError)}};if(hasBigIntSupport){const big={zero:BigInt(0),one:BigInt(1),two:BigInt(2),eight:BigInt(8),ff:BigInt(255)};bigIntFunctions.bigintToBytes=function bigintToBytes(number){if(typeof number!=="bigint"){throw new Error("number must be a bigint")}const bytes=[];const negative=number<big.zero;do{const byte=Number(number&big.ff);bytes.push(byte);number=number>>big.eight}while(number!==(negative?-big.one:big.zero));bytes.reverse();if(negative?bytes[0]<128:bytes[0]>=128){bytes.unshift(negative?255:0)}return bytes};bigIntFunctions.bytesToBigint=function bytesToBigint(bytes){const negative=bytes[0]>=128;let number=big.zero;for(let b of bytes){if(negative){b=~b&255}number=(number<<big.eight)+BigInt(b)}if(negative){number=-(number+big.one)}return number}}exports.bigintToBytes=bigIntFunctions.bigintToBytes;exports.bytesToBigint=bigIntFunctions.bytesToBigint;function encodeString(str){if(typeof TextEncoder!=="undefined"){const encoder=new TextEncoder;return encoder.encode(str)}else if(typeof Buffer==="function"){const buf=Buffer.from(str,"utf-8");return new Uint8Array(buf.buffer,buf.byteOffset,buf.byteLength)}else{const arr=[];for(let i=0;i<str.length;i++){let code=str.charCodeAt(i);if(code>128){if((code&55296)===55296){const nextCode=str.charCodeAt(i+1);if((nextCode&56320)!==56320){throw new Error("follow-up utf-16 character does not start with 0xDC00")}i++;const p1=code&1023;const p2=nextCode&1023;code=65536|p1<<10|p2}if(code<2048){const b1=192|code>>6&31;const b2=128|code&63;arr.push(b1,b2)}else if(code<65536){const b1=224|code>>12&15;const b2=128|code>>6&63;const b3=128|code&63;arr.push(b1,b2,b3)}else if(code<2097152){const b1=240|code>>18&7;const b2=128|code>>12&63;const b3=128|code>>6&63;const b4=128|code&63;arr.push(b1,b2,b3,b4)}else{throw new Error(`Cannot convert character ${str.charAt(i)} (code ${code}) to utf-8`)}}else{arr.push(code<128?code:63)}}return new Uint8Array(arr)}}exports.encodeString=encodeString;function decodeString(buffer){if(typeof TextDecoder!=="undefined"){const decoder=new TextDecoder;if(buffer instanceof Uint8Array){return decoder.decode(buffer)}const buf=Uint8Array.from(buffer);return decoder.decode(buf)}else if(typeof Buffer==="function"){if(buffer instanceof Array){buffer=Uint8Array.from(buffer)}if(!(buffer instanceof Buffer)&&"buffer"in buffer&&buffer.buffer instanceof ArrayBuffer){const typedArray=buffer;buffer=Buffer.from(typedArray.buffer,typedArray.byteOffset,typedArray.byteLength)}if(!(buffer instanceof Buffer)){throw new Error("Unsupported buffer argument")}return buffer.toString("utf-8")}else{if(!(buffer instanceof Uint8Array)&&"buffer"in buffer&&buffer["buffer"]instanceof ArrayBuffer){const typedArray=buffer;buffer=new Uint8Array(typedArray.buffer,typedArray.byteOffset,typedArray.byteLength)}if(buffer instanceof Buffer||buffer instanceof Array||buffer instanceof Uint8Array){let str="";for(let i=0;i<buffer.length;i++){let code=buffer[i];if(code>128){if((code&240)===240){const b1=code,b2=buffer[i+1],b3=buffer[i+2],b4=buffer[i+3];code=(b1&7)<<18|(b2&63)<<12|(b3&63)<<6|b4&63;i+=3}else if((code&224)===224){const b1=code,b2=buffer[i+1],b3=buffer[i+2];code=(b1&15)<<12|(b2&63)<<6|b3&63;i+=2}else if((code&192)===192){const b1=code,b2=buffer[i+1];code=(b1&31)<<6|b2&63;i++}else{throw new Error("invalid utf-8 data")}}if(code>=65536){code^=65536;const p1=55296|code>>10;const p2=56320|code&1023;str+=String.fromCharCode(p1);str+=String.fromCharCode(p2)}else{str+=String.fromCharCode(code)}}return str}else{throw new Error("Unsupported buffer argument")}}}exports.decodeString=decodeString;function concatTypedArrays(a,b){const c=new a.constructor(a.length+b.length);c.set(a);c.set(b,a.length);return c}exports.concatTypedArrays=concatTypedArrays;function cloneObject(original,stack){var _a;if(((_a=original===null||original===void 0?void 0:original.constructor)===null||_a===void 0?void 0:_a.name)==="DataSnapshot"){throw new TypeError(`Object to clone is a DataSnapshot (path "${original.ref.path}")`)}const checkAndFixTypedArray=obj=>{if(obj!==null&&typeof obj==="object"&&typeof obj.constructor==="function"&&typeof obj.constructor.name==="string"&&["Buffer","Uint8Array","Int8Array","Uint16Array","Int16Array","Uint32Array","Int32Array","BigUint64Array","BigInt64Array"].includes(obj.constructor.name)){obj=obj.buffer.slice(obj.byteOffset,obj.byteOffset+obj.byteLength)}return obj};original=checkAndFixTypedArray(original);if(typeof original!=="object"||original===null||original instanceof Date||original instanceof ArrayBuffer||original instanceof path_reference_1.PathReference||original instanceof RegExp){return original}const cloneValue=val=>{if(stack.indexOf(val)>=0){throw new ReferenceError("object contains a circular reference")}val=checkAndFixTypedArray(val);if(val===null||val instanceof Date||val instanceof ArrayBuffer||val instanceof path_reference_1.PathReference||val instanceof RegExp){return val}else if(typeof val==="object"){stack.push(val);val=cloneObject(val,stack);stack.pop();return val}else{return val}};if(typeof stack==="undefined"){stack=[original]}const clone=original instanceof Array?[]:original instanceof partial_array_1.PartialArray?new partial_array_1.PartialArray:{};Object.keys(original).forEach((key=>{const val=original[key];if(typeof val==="function"){return}clone[key]=cloneValue(val)}));return clone}exports.cloneObject=cloneObject;const isTypedArray=val=>typeof val==="object"&&["ArrayBuffer","Buffer","Uint8Array","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array"].includes(val.constructor.name);function valuesAreEqual(val1,val2){if(val1===val2){return true}if(typeof val1!==typeof val2){return false}if(typeof val1==="object"||typeof val2==="object"){if(val1===null||val2===null){return false}if(val1 instanceof path_reference_1.PathReference||val2 instanceof path_reference_1.PathReference){return val1 instanceof path_reference_1.PathReference&&val2 instanceof path_reference_1.PathReference&&val1.path===val2.path}if(val1 instanceof Date||val2 instanceof Date){return val1 instanceof Date&&val2 instanceof Date&&val1.getTime()===val2.getTime()}if(val1 instanceof Array||val2 instanceof Array){return val1 instanceof Array&&val2 instanceof Array&&val1.length===val2.length&&val1.every(((item,i)=>valuesAreEqual(val1[i],val2[i])))}if(isTypedArray(val1)||isTypedArray(val2)){if(!isTypedArray(val1)||!isTypedArray(val2)||val1.byteLength===val2.byteLength){return false}const typed1=val1 instanceof ArrayBuffer?new Uint8Array(val1):new Uint8Array(val1.buffer,val1.byteOffset,val1.byteLength),typed2=val2 instanceof ArrayBuffer?new Uint8Array(val2):new Uint8Array(val2.buffer,val2.byteOffset,val2.byteLength);return typed1.every(((val,i)=>typed2[i]===val))}const keys1=Object.keys(val1),keys2=Object.keys(val2);return keys1.length===keys2.length&&keys1.every((key=>keys2.includes(key)))&&keys1.every((key=>valuesAreEqual(val1[key],val2[key])))}return false}exports.valuesAreEqual=valuesAreEqual;class ObjectDifferences{constructor(added,removed,changed){this.added=added;this.removed=removed;this.changed=changed}forChild(key){if(this.added.includes(key)){return"added"}if(this.removed.includes(key)){return"removed"}const changed=this.changed.find((ch=>ch.key===key));return changed?changed.change:"identical"}}exports.ObjectDifferences=ObjectDifferences;function compareValues(oldVal,newVal,sortedResults=false){const voids=[undefined,null];if(oldVal===newVal){return"identical"}else if(voids.indexOf(oldVal)>=0&&voids.indexOf(newVal)<0){return"added"}else if(voids.indexOf(oldVal)<0&&voids.indexOf(newVal)>=0){return"removed"}else if(typeof oldVal!==typeof newVal){return"changed"}else if(isTypedArray(oldVal)||isTypedArray(newVal)){if(!isTypedArray(oldVal)||!isTypedArray(newVal)){return"changed"}const typed1=oldVal instanceof Uint8Array?oldVal:oldVal instanceof ArrayBuffer?new Uint8Array(oldVal):new Uint8Array(oldVal.buffer,oldVal.byteOffset,oldVal.byteLength);const typed2=newVal instanceof Uint8Array?newVal:newVal instanceof ArrayBuffer?new Uint8Array(newVal):new Uint8Array(newVal.buffer,newVal.byteOffset,newVal.byteLength);return typed1.byteLength===typed2.byteLength&&typed1.every(((val,i)=>typed2[i]===val))?"identical":"changed"}else if(oldVal instanceof Date||newVal instanceof Date){return oldVal instanceof Date&&newVal instanceof Date&&oldVal.getTime()===newVal.getTime()?"identical":"changed"}else if(oldVal instanceof path_reference_1.PathReference||newVal instanceof path_reference_1.PathReference){return oldVal instanceof path_reference_1.PathReference&&newVal instanceof path_reference_1.PathReference&&oldVal.path===newVal.path?"identical":"changed"}else if(typeof oldVal==="object"){const isArray=oldVal instanceof Array;const getKeys=obj=>{let keys=Object.keys(obj).filter((key=>!voids.includes(obj[key])));if(isArray){keys=keys.map((v=>parseInt(v)))}return keys};const oldKeys=getKeys(oldVal);const newKeys=getKeys(newVal);const removedKeys=oldKeys.filter((key=>!newKeys.includes(key)));const addedKeys=newKeys.filter((key=>!oldKeys.includes(key)));const changedKeys=newKeys.reduce(((changed,key)=>{if(oldKeys.includes(key)){const val1=oldVal[key];const val2=newVal[key];const c=compareValues(val1,val2);if(c!=="identical"){changed.push({key:key,change:c})}}return changed}),[]);if(addedKeys.length===0&&removedKeys.length===0&&changedKeys.length===0){return"identical"}else{return new ObjectDifferences(addedKeys,removedKeys,sortedResults?changedKeys.sort(((a,b)=>a.key<b.key?-1:1)):changedKeys)}}return"changed"}exports.compareValues=compareValues;function getMutations(oldVal,newVal,sortedResults=false){const process=(target,compareResult,prev,val)=>{switch(compareResult){case"identical":return[];case"changed":return[{target:target,prev:prev,val:val}];case"added":return[{target:target,prev:null,val:val}];case"removed":return[{target:target,prev:prev,val:null}];default:{let changes=[];compareResult.added.forEach((key=>changes.push({target:target.concat(key),prev:null,val:val[key]})));compareResult.removed.forEach((key=>changes.push({target:target.concat(key),prev:prev[key],val:null})));compareResult.changed.forEach((item=>{const childChanges=process(target.concat(item.key),item.change,prev[item.key],val[item.key]);changes=changes.concat(childChanges)}));return changes}}};const compareResult=compareValues(oldVal,newVal,sortedResults);return process([],compareResult,oldVal,newVal)}exports.getMutations=getMutations;function getChildValues(childKey,oldValue,newValue){oldValue=oldValue===null?null:oldValue[childKey];if(typeof oldValue==="undefined"){oldValue=null}newValue=newValue===null?null:newValue[childKey];if(typeof newValue==="undefined"){newValue=null}return{oldValue:oldValue,newValue:newValue}}exports.getChildValues=getChildValues;function defer(fn){process_1.default.nextTick(fn)}exports.defer=defer;function getGlobalObject(){var _a;if(typeof globalThis!=="undefined"){return globalThis}if(typeof global!=="undefined"){return global}if(typeof window!=="undefined"){return window}if(typeof self!=="undefined"){return self}return(_a=function(){return this}())!==null&&_a!==void 0?_a:Function("return this")()}exports.getGlobalObject=getGlobalObject}).call(this)}).call(this,typeof global!=="undefined"?global:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{},require("buffer").Buffer)},{"./partial-array":46,"./path-reference":48,"./process":49,buffer:59}],59:[function(require,module,exports){},{}]},{},[6])(6)}));